#+STARTUP: overview
* .emacs.d

#+BEGIN_SRC sh :results silent
cd && git clone git@github.com:torgeir/.emacs.d.git
#+END_SRC

Load this file when emacs starts.

#+BEGIN_SRC emacs-lisp :results silent
(find-file (locate-user-emacs-file "readme.org"))
#+END_SRC

* os setup
** shortcuts

#+BEGIN_SRC sh :results silent
ln -s ~/.emacs.d/emacsclient ~/bin/e
ln -s ~/.emacs.d/emacsclient-terminal ~/bin/em
#+END_SRC

** deps

#+BEGIN_SRC sh :results silent
npm install eslint babel-eslint jsonlint eslint-plugin-react typescript-language-server typescript jscodeshift browser-sync
#+END_SRC

** os x

#+BEGIN_SRC sh :results silent
brew tap d12frosted/emacs-plus
brew install emacs-plus --HEAD --with-natural-title-bar --without-spacemacs-icon
#+END_SRC

** ubuntu

#+BEGIN_SRC sh :results silent
sudo add-apt-repository -y ppa:ubuntu-elisp
sudo apt update
sudo apt install emacs-snapshot
sudo apt install fonts-inconsolata
sudo fc-cache -fv
#+END_SRC

* sanity

Remove the startup message.
 
#+BEGIN_SRC emacs-lisp :results silent
(setq inhibit-startup-message t)
#+END_SRC

Make shift work i org-mode.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-support-shift-select t)
#+END_SRC

* bootstrap

Default to calling straigth-use-package when running use-package.

#+BEGIN_SRC emacs-lisp :results silent
;;; -*- lexical-binding: t; -*-
(setq straight-use-package-by-default t)
#+END_SRC

Bootstrap [straight.el](https://github.com/raxod502/straight.el).

#+BEGIN_SRC emacs-lisp :results silent
    (defvar bootstrap-version)
    (let ((bootstrap-file
	   (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
	  (bootstrap-version 5))
      (unless (file-exists-p bootstrap-file)
	(with-current-buffer
	    (url-retrieve-synchronously
	     "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
	     'silent 'inhibit-cookies)
	  (goto-char (point-max))
	  (eval-print-last-sexp)))
      (load bootstrap-file nil 'nomessage))

;; todo inline
(load "~/.emacs.d/t-bootstrap.el")
#+END_SRC

Install [use-package](https://github.com/jwiegley/use-package).

#+BEGIN_SRC emacs-lisp :results silent
(straight-use-package 'use-package)
(eval-when-compile (require 'use-package))
#+END_SRC

* customization
  
#+BEGIN_SRC emacs-lisp :results silent
(setq custom-file (locate-user-emacs-file "custom.el"))
(load custom-file)
#+END_SRC

* before
#+BEGIN_SRC emacs-lisp :results silent
(t/timing-start)
#+END_SRC

* macros
  #+BEGIN_SRC emacs-lisp :results silent
(require 'subr-x)

(defmacro comment (&rest ignore)
  "Ignore stuff, return `nil'."
  nil)

(defmacro t/lambda (&optional args &rest body)
  (declare (indent 1))
  (if body
      `(lambda ,args (interactive) ,@body)
    `(lambda (&optional &rest ignore) (interactive) ,args)))

(comment
 (t/lambda)
 (t/lambda 1)
 (t/lambda (one two) 1))

(defmacro t/after (file-name &rest body)
  (declare (indent 1))
  (if (locate-library (symbol-name file-name))
      `(with-eval-after-load ',file-name ,@body)
    (message "t/after: for %s is not a filename in load-path?" file-name)))

(defmacro t/when-ext (ext &rest body)
  "Run `body' when buffer's file has extension `ext'."
  (declare (indent 1))
  `(let ((ext-re (concat "\\." ,ext "$")))
     (when (and (buffer-file-name)
                (string-match ext-re (buffer-file-name)))
       ,@body)))

(defun t/ensure-list (i-or-is)
  "Ensure `i-or-is' is a list."
  (if (and (listp i-or-is)
           (not (functionp i-or-is)) ; lambda
           )
      i-or-is
    (list i-or-is)))

(defmacro t/add-hook (hook-or-hooks fn-or-fns &optional append local)
  "Add one or more hook fns."
  (comment (dolist (hook (t/ensure-list (eval hook-or-hooks)))
             (unless (or (boundp hook) (listp hook))
               (message "%s is not a hook" hook))))
  `(let ((hooks (t/ensure-list ,hook-or-hooks))
         (fns (t/ensure-list ,fn-or-fns)))
     (dolist (hook hooks)
       (dolist (fn fns)
         (add-hook hook fn ,append ,local)))))

(defmacro t/remove-hook (hook-or-hooks fn-or-fns)
  "Remove one or more hook fns"
  `(let ((hooks (t/ensure-list ,hook-or-hooks))
         (fns (t/ensure-list ,fn-or-fns)))
     (dolist (hook hooks)
       (dolist (fn fns)
         (remove-hook hook fn)))))

(defmacro t/add-hook-setq (hook-or-hooks var_ val_ &rest vars_)
  "A `setq' run in hooks."
  `(t/add-hook ,hook-or-hooks
               (lambda nil
                 (let ((var (quote ,var_))
                       (val (quote ,val_))
                       (vars (quote ,vars_))
                       (bindings '(setq)))
                   (while var
                     (setq bindings (cons val (cons var bindings))
                           var (and vars (pop vars))
                           val (and vars (pop vars))))
                   (eval (nreverse (copy-list bindings)))))))

(defmacro t/bind-in (maps_ key_ fn_ &rest bindings)
  "Bind keys in maps."
  (declare (indent 1))
  `(let ((maps (t/ensure-list ,maps_))
         (key (quote ,key_))
         (fn (quote ,fn_))
         (bs (quote ,bindings)))
     (while key
       (dolist (map maps)
         (eval `(bind-key ,key ,fn ,map)))
       (setq key (and bs (pop bs))
             fn (and bs (pop bs))))))

(defmacro t/add-hook-defun (hook-or-hooks fn &rest body)
  "Create a defun `fn' with `body' in `hook-or-hooks'."
  `(progn
     (defun ,fn ()
       (interactive)
       ;; TODO
       ;;(unless (helm-window)
       ,@body)
     ;;TODO)
     (t/add-hook ,hook-or-hooks (quote ,fn))))

(defmacro t/macro-helm-ag-insert (thing fn)
  `(lambda ()
     (interactive)
     ;; TODO 
     ;;(setq-local helm-ag-insert-at-point ,thing)
     (,fn)
     ;; TODO 
     ;;(setq-local helm-ag-insert-at-point nil)
     ))

(defmacro t/idle-timer (name fn every-minute)
  "Reloadable variant of run-with-idle-timer."
  `(progn
     (when (and (boundp ',name) ,name) (cancel-timer ,name))
     (setq ,name (run-with-idle-timer (* ,every-minute 60) t ,fn))))

(defmacro t/safe-call (fn)
  "Expands to call `fn' only if it is bound to a function."
  `(when (fboundp (quote ,fn))
     (funcall (quote ,fn))))

(progn

  (defvar t-use-package-pkgs nil
    "List of all packages inited by t/use-package that will be used
for setting up vars and config after load")
  (setq t-use-package-pkgs nil)

  (defmacro t/use-package (package &optional key value &rest bindings)
    (declare (indent 1))
    (let* ((entries '())
           (init-name (intern (format "t/init-%s" package)))
           (vars-name (intern (format "t/vars-%s" package)))
           (config-name (intern (format "t/config-%s" package))))

      (while key
        (push value entries)
        (push key entries)
        (setq key (pop bindings)
              value (pop bindings)))

      (let* ((init-body (plist-get entries :init))
             (config-body (plist-get entries :config))
             (body '()))

        ;; make :init and :config call defuns instead
        (setq entries (plist-put entries :init `(,vars-name)))
        (setq entries (plist-put entries :config `(,config-name)))

        ;; pass through some other use-package keys
        (let ((ks (list :if :init :config :mode :bind :ensure :diminish :after
                        :hook :commands :defer :load-path :pin :evil-state)))
          (dolist (k ks)
            (when (plist-member entries k)
              (let ((v (plist-get entries k)))
                (setq body (plist-put body k v))))))

        (add-to-list 't-use-package-pkgs init-name t)
        (setq t-use-package-pkgs (delete-dups t-use-package-pkgs))

        `(progn
           (defun ,vars-name ()
             (interactive)
             (when *t-debug-init*
               (message "t/use-package vars: %s" (symbol-name ',vars-name)))
             ,init-body)
           (defun ,config-name ()
             (interactive)
             (when *t-debug-init*
               (message "t/use-package config: %s" (symbol-name ',config-name)))
             ,config-body)
           (defun ,init-name ()
             (interactive)
             (when *t-debug-init*
               (message "t/use-package init: %s" (symbol-name ',init-name)))
             (use-package ,package ,@body)))))))

;; tests

(comment
 (plist-member '(:one nil :two 2) :one)
 (plist-member '(:one nil :two 2) :ensure)

 (pp (macroexpand-1 '(t/use-package wow
                       :ensure nil
                       :commands (winner-mode)
                       :bind (:map winner-mode-map ("C-c <left>" . winner-undo)))))
 )

(comment

 (t/use-package winner
   :bind (:map winner-mode-map ("C-c <left>" . winner-undo))
   :init (message "init")
   :config (message "config"))

 t-use-package-pkgs

 (symbol-function 't/vars-winner)
 (symbol-function 't/config-winner)
 (symbol-function 't/init-winner))

(comment
 (delete-dups '(1 2 3 1 2 3)))

(comment
 (t/use-package whaat
   :config
   (progn
     (message "config what one")
     (message "config what two"))
   :bind (+ 1 2))

 (symbol-function 't/vars-whaat)
 (symbol-function 't/config-whaat)
 (symbol-function 't/init-whaat))

(comment
 (symbol-function 't/config-which-key))

(defmacro t/def-pairs (pairs)
  "Create smartsmartparens wrapping function, e.g. t/wrap-with-paren"
  `(progn
     ,@(loop for (key . val) in pairs
             collect
             `(defun ,(read (concat
                             "t/wrap-with-"
                             (prin1-to-string key)
                             "s"))
                  (&optional arg)
                (interactive "p")
                (sp-wrap-with-pair ,val)))))

(provide 't-macros)
  #+END_SRC
  
* evil

#+BEGIN_SRC emacs-lisp :results silent
    ;;; -*- lexical-binding: t; -*-
    (setq evil-want-C-d-scroll t
	  evil-want-C-u-scroll t
	  evil-want-keybinding nil
	  evil-want-integration t
	  evil-want-Y-yank-to-eol nil
	  evil-move-beyond-eol nil)

    (setq evil-default-state 'normal
	  evil-insert-skip-empty-lines t
	  evil-search-module 'evil-search)

    (t/use-package evil
      :init
      (progn
	;; https://emacs.stackexchange.com/a/15054
	(fset 'evil-visual-update-x-selection 'ignore)))

    (t/use-package evil-anzu
      :init
      (progn
	(setq anzu-cons-mode-line-p nil
	      anzu-minimum-input-length 1
	      anzu-search-threshold 100)))

    (t/use-package evil-escape
      :after evil
      :init
      (progn
	(setq-default evil-escape-key-sequence "jk"
		      evil-escape-delay 0.1))
      :config
      (evil-escape-mode))

    (t/use-package evil-leader
      :after evil
      :init
      (progn
	(setq evil-leader/in-all-states t
	      evil-leader/non-normal-prefix t-emacs-leader))
      :config
      (progn
	(evil-leader/set-leader t-leader)
	;; TODO remove?
	;;(evil-mode nil)
	;;(global-evil-leader-mode)
	;;(evil-mode 1)
	(t/bind-in '(evil-normal-state-map evil-motion-state-map)
	  "Y" 't/evil-yank-to-end-of-line)))

    (t/use-package evil-collection
      :after evil
      :init
      (progn
	(setq evil-collection-key-blacklist '("ZZ" "ZQ"))
	(evil-collection-init)
	(t/after org
	  (evil-collection-define-key 'normal 'outline-mode-map (kbd "<tab>") 'org-cycle))
	(progn
	  ;; https://github.com/jtbm37/all-the-icons-dired/pull/19
	  (t/after evil-collection
	    (defvar-local +wdired-icons-enabled nil)
	    (defun +wdired-before-start-advice ()
	      "Execute when switching from `dired' to `wdired'."
	      (setq +wdired-icons-enabled (if (bound-and-true-p all-the-icons-dired-mode)
					      1 0))
	      (when (bound-and-true-p all-the-icons-dired-mode)
		(all-the-icons-dired-mode 0)))
	    (defun +wdired-after-finish-advice ()
	      "Execute when switching from `wdired' to `dired'"
	      (when (boundp 'all-the-icons-dired-mode)
		(all-the-icons-dired-mode +wdired-icons-enabled)))
	    (advice-add 'wdired-change-to-wdired-mode :before #'+wdired-before-start-advice)
	    (advice-add 'wdired-change-to-dired-mode :after #'+wdired-after-finish-advice)))))

    (t/use-package evil-matchit
      :commands evilmi-jump-items
      :config
      (progn
	(global-evil-matchit-mode 1)))

    (t/use-package evil-visualstar
      :commands (evil-visualstar/begin-search-forward
		 evil-visualstar/begin-search-backward)
      :config
      (progn
	(t/bind-in 'evil-visual-state-map
	  "*" 'evil-visualstar/begin-search-forward
	  "#" 'evil-visualstar/begin-search-backward)))

    (t/use-package evil-cleverparens
      :diminish evil-cleverparens-mode
      :defer 1
      :init
      (progn
	(t/add-hook-defun
	 'evil-cleverparens-enabled-hook t-evil-cp-mode-hook
	 (evil-define-key 'visual evil-cleverparens-mode-map (kbd "M-d") 'evil-multiedit-match-symbol-and-next)
	 (evil-define-key 'normal evil-cleverparens-mode-map (kbd "M-d") 'evil-multiedit-match-symbol-and-next))
	(setq evil-cleverparens-use-additional-bindings t
	      evil-cleverparens-use-regular-insert t))
      :config
      (t/after evil-surround
	(add-to-list 'evil-surround-operator-alist '(evil-cp-delete . delete))
	(add-to-list 'evil-surround-operator-alist '(evil-cp-change . change))))

    (t/use-package evil-surround
      :defer 1
      :config
      (progn
	(global-evil-surround-mode 1)
	;; the opposite of vim, like spacemacs
	(evil-define-key 'visual evil-surround-mode-map "S" 'evil-substitute)
	(evil-define-key 'visual evil-surround-mode-map "s" 'evil-surround-region)))

    (t/use-package evil-snipe
      :defer 1
      :init
      (t/add-hook-defun 'prog-mode-hook t-hook-snipe
			(evil-snipe-local-mode 1)
			(evil-snipe-override-local-mode 1)))

    (t/use-package evil-multiedit
      :commands evil-multiedit-match-symbol-and-next
      :init
      (progn
	(setq evil-multiedit-follow-matches t)
	(t/bind-in 'evil-normal-state-map
	  "M-d" 'evil-multiedit-match-symbol-and-next
	  "C-M-r" 'evil-multiedit-restore))
      :config
      (progn
	(evil-multiedit-default-keybinds)
	(unbind-key "M-d" evil-insert-state-map)
	(unbind-key "C-M-D" evil-normal-state-map)
	(bind-key "gn" 'evil-multiedit--visual-line evil-multiedit-state-map)

	(progn
	  (setq evil-multiedit-store-in-search-history t)

	  (defun t/mc-skip-prev ()
	    (interactive)
	    (evil-multiedit-toggle-or-restrict-region)
	    (evil-multiedit-match-and-prev))

	  (defun t/mc-skip-next ()
	    (interactive)
	    (evil-multiedit-toggle-or-restrict-region)
	    (evil-multiedit-match-and-next))

	  (t/bind-in 'evil-multiedit-state-map
	    "M-j" #'t/mc-skip-next
	    "M-k" #'t/mc-skip-prev))))

    (t/use-package evil-commentary
      :defer 1
      :init (evil-commentary-mode))

    (t/use-package google-translate
      :commands google-translate-at-point)

    (t/use-package evil-goggles
      :defer 1
      :init
      (progn
	(setq evil-goggles-duration 0.2
	      evil-goggles-async-duration 0.2
	      evil-goggles-pulse t))
      :config
      (t/add-hook-defun 'prog-mode-hook t/hook-goggles
			(evil-goggles-mode)
			(evil-goggles-use-magit-faces)))

    ;; dependencies of evil-extra-operator
    (use-package highlight)
    (use-package fold-this
      :after highlight)

    (t/use-package evil-extra-operator
      :after fold-this
      :defer 1
      :init
      (setq evil-extra-operator-org-capture-key "gC")
      :config
      (global-evil-extra-operator-mode 1))

    (defvar t-evil-major-modes '(compilation-mode
				 special-mode
				 calendar-mode
				 git-rebase-mode
				 diff-mode
				 gnus-group-mode
				 gnus-summary-mode)
      "Major modes that should trigger evil emacs state when changed to.")

  (evil-mode 1)
(global-evil-leader-mode)

    (t/after evil
      (t/add-hook-defun 'after-change-major-mode-hook t/hook-major-mode
			(when (member major-mode t-evil-major-modes)
			  (evil-emacs-state))))


      (t/add-hook '(git-commit-mode-hook org-capture-mode-hook) 'evil-insert-state)

      (defun t/init-evil-cursors (&rest _)
	"Change cursors after theme colors have loaded."
	(setq evil-default-cursor (face-background 'cursor nil t)
	      evil-emacs-state-cursor  `(,(face-foreground 'warning) box)
	      evil-normal-state-cursor 'box
	      evil-insert-state-cursor 'bar
	      evil-visual-state-cursor 'hollow))
      (advice-add #'load-theme :after #'t/init-evil-cursors)

      (defvar +evil-esc-hook '(t)
	"A hook run after ESC is pressed in normal mode (invoked by
    `evil-force-normal-state'). If a hook returns non-nil, all hooks after it are
    ignored.")

      (defun +evil*attach-escape-hook (&optional ignore)
	"Run all `+evil-esc-hook' hooks. If any returns non-nil, stop there."
	(cond (;; quit the minibuffer if open.
	       (minibuffer-window-active-p (minibuffer-window))
	       (abort-recursive-edit))
	      ;; disable ex search buffer highlights.
	      ((evil-ex-hl-active-p 'evil-ex-search)
	       (evil-ex-nohighlight))
	      ;; escape anzu number of matches
	      ((and (featurep 'anzu)
		    anzu--state)
	       (anzu--reset-status))
	      ;; remove highlights
	      ((and (featurep 'highlight-symbol)
		    highlight-symbol-mode)
	       (highlight-symbol-remove-all))
	      ;; Run all escape hooks. If any returns non-nil, then stop there.
	      (t (run-hook-with-args-until-success '+evil-esc-hook))))
      (advice-add #'evil-force-normal-state :after #'+evil*attach-escape-hook)

      ;; motions keys for help buffers
      (evil-define-key 'motion help-mode-map (kbd "q") 'quit-window)
      (evil-define-key 'motion help-mode-map (kbd "<tab>") 'forward-button)
      (evil-define-key 'motion help-mode-map (kbd "S-<tab>") 'backward-button)
      (evil-define-key 'motion help-mode-map (kbd "L") 'help-go-forward)
      (evil-define-key 'motion help-mode-map (kbd "H") 'help-go-back)
      (evil-define-key 'motion help-mode-map (kbd "gf") 'help-go-forward)
      (evil-define-key 'motion help-mode-map (kbd "gb") 'help-go-back)
      (evil-define-key 'motion help-mode-map (kbd "gh") 'help-follow-symbol)

      ;; motion keys for info mode
      (evil-define-key 'normal Info-mode-map (kbd "H") 'Info-history-back)
      (evil-define-key 'normal Info-mode-map (kbd "L") 'Info-history-forward)
      (unbind-key (kbd "h") Info-mode-map)
      (unbind-key (kbd "l") Info-mode-map)

      ;; i_Ctrl-o - C-o from hybrid mode, like in vim insert mode
      (evil-define-key 'hybrid global-map (kbd "C-o") 'evil-execute-in-normal-state)

      ;; some emacs stuff is useful, in terminals etc
      ;; http://stackoverflow.com/a/16226006
      (t/bind-in '(evil-normal-state-map
		   evil-insert-state-map
		   evil-visual-state-map
		   evil-motion-state-map)
	"C-a" 't/smart-beginning-of-line
	"C-e" 'end-of-line
	"C-b" 'evil-backward-char
	"C-f" 'evil-forward-char
	"C-k" 'kill-line
	"C-n" 'evil-next-line
	"C-p" 'evil-previous-line
	"C-w" 'evil-delete-backward-word
	;; TODO bring back kill ring
	;;"M-y" 'helm-show-kill-ring
	)

      (t/bind-in 'evil-insert-state-map
	"C-d" 'evil-delete-char
	"C-u" (t/lambda (kill-line 0)))

      (t/bind-in '(evil-normal-state-map
		   evil-visual-state-map)
	"Q" 'call-last-kbd-macro
	"C-y" 'evil-paste-pop ; cycle after pasting with p
	"C-S-y" (t/lambda (evil-paste-pop-next 1)))

      (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-map)
      (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-ns-map)
      (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-completion-map)
      (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-must-match-map)
      (bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-isearch-map)

      ;; macro camelCase to snakeCase
      (evil-set-register ?c [?: ?s ?/ ?\\ ?\( ?\[ ?a ?- ?z ?0 ?- ?9 ?\] ?\\ ?\) ?\\ ?\( ?\[ ?A ?- ?Z ?0 ?- ?9 ?\] ?\\ ?\) ?/ ?\\ ?1 ?_ ?\\ ?l ?\\ ?2 ?/ ?g])

#+END_SRC

* themes

#+BEGIN_SRC emacs-lisp :results silent
(use-package doom-modeline
  :config
  (progn
    (setq doom-modeline-height 40
          doom-themes-padded-modeline 1)
    ;;(t/add-hook-setq 'js2-mode-hook doom-modeline-env-command "node -v 2>&1")
))

(use-package doom-themes
  :config
  (progn
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    (doom-themes-visual-bell-config)
    ;;(t/add-hook 'org-mode-hook 'doom-themes-org-config)
    ;;(t/add-hook 'neotree-mode-hook 'doom-themes-neotree-config)
    (load-theme 'doom-one)
))
#+END_SRC

* server

#+BEGIN_SRC emacs-lisp :results silent
(unless (fboundp 'server-running-p) (require 'server))
(unless (server-running-p) (server-mode))
#+END_SRC

* after
#+BEGIN_SRC emacs-lisp :results silent
(t/timing-end)
#+END_SRC
