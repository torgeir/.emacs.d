#+STARTUP: show2levels
* torgeir/.doom.d
:PROPERTIES:
:header-args:emacs-lisp: :lexical t :results silent
:END:

Managing [[https://github.com/torgeir/.emacs.d/tree/d1c9dec646824ab7396b8a35fd7da1416a0580d3][a plain emacs config]] that got closer and closer to what you get ootb with [[https://github.com/doomemacs/doomemacs][doom emacs]] was beginning to feel tedious, so this is an attempt to for a setup with ~feature parity on top of doom emacs. It was probably due a clean up after all these years.

** Install

First, install doom emacs.

#+begin_src sh :tangle no
git clone --depth 1 https://github.com/doomemacs/doomemacs ~/.emacs.d
~/.emacs.d/bin/doom install
#+end_src

Then the config.

#+begin_src sh :tangle no
cd && git clone git@github.com:torgeir/.emacs.d.git ~/.doom.d
#+end_src

And some terminal shortcuts

#+begin_src sh :tangle no
ln -s ~/.emacs.d/emacsclient ~/bin/e
ln -s ~/.emacs.d/emacsclient-terminal ~/bin/em
#+end_src

** Doom help

The built in emacs help is fantastic. The doom one on ~SPC h d~ is even better! Here's a few examples.

- [[file:~/.emacs.d/docs/examples.org][Browse examples of useful apis]]
- [[elisp:(call-interactively 'doom/help-modules)][Lookup help for doom modules]]
- [[elisp:(call-interactively 'doom/help-search)][Search for in the doom .emacs.d folder]]
- ~SPC h d h~  to access documentation
- ~SPC h d~ followed by ~C-h~ invokes a fuzzy search of keys available in the formerly pressed binding.
- ~K~ on a module to view its documentation
- ~gd~ on a module to browse its directory

** Literate config

This config uses the =:config literal= that tangles this file to ~config.el~ on save. The [[file:init.el::setq +literate-config-file (concat (getenv "HOME") "/.doom.d/readme.org")][+literate-config-file]] is set in ~init.el~ and points to this file.

** Packages

This is tangled to ~packages.el~ on save.

#+begin_src emacs-lisp :tangle packages.el
(package! evil-cleverparens)
(package! transpose-frame)
(package! highlight-symbol)
(package! olivetti)
(package! focus)
(package! spray)
(package! dired-subtree)
#+end_src

** Lexical scoping everywhere

The madness that is dynamic is too much for anyone, really.

#+begin_src emacs-lisp
;;; $DOOMDIR/config.el -*- lexical-binding: t; -*-
#+end_src

** Recentf

Ignore some of the cached emacs files in recent files

#+begin_src emacs-lisp
(after! recentf
  (add-to-list 'recentf-exclude "\.emacs\.d/\.local"))
#+end_src

** Whoami

#+begin_quote
;; Some functionality uses this to identify you, e.g. GPG configuration, email
;; clients, file templates and snippets. It is optional.
#+end_quote

#+begin_src emacs-lisp
(setq user-full-name "Torgeir Thoresen"
      user-mail-address "torgeir.thoresen@gmail.com")
#+end_src

** Org file location setup

#+begin_quote
;; If you use `org' and don't want your org files in the default location below,
;; change `org-directory'. It must be set before org loads!
#+end_quote

#+begin_src emacs-lisp
(setq org-directory (expand-file-name "~/Dropbox/org/")
      org-agenda-files '("~/Dropbox/org")
      org-archive-location "%s_archive.gpg::") ; so files are encrypted automatically
#+end_src

** t-defuns

My old collection of more or less usefull defuns.

#+begin_src emacs-lisp
(progn
  (defun t/user-file (path) (concat (expand-file-name "~/") path))
  (defun t/user-emacs-file (path) (concat (expand-file-name "~/.doom.d/") path))
  (defun t/user-dropbox-folder (path) (expand-file-name (concat "~/Dropbox (Personal)/" path)))
  (defconst is-win IS-WINDOWS)
  (defconst is-cygwin IS-WINDOWS)
  (defconst is-mac IS-MAC)
  (defconst is-linux IS-LINUX)
  (load! "./t-defuns.el"))
#+end_src

** Micro state

A small overlay map that exposes a set of key bindings until you press q, or something else not in the keymap.

#+begin_src emacs-lisp
(defun t/micro-state (quit key fn &rest bindings)
  "Micro state that temporarily overlays a new key map, kinda like hydra"
  (let ((keymap (make-sparse-keymap)))
    (while key
      (bind-key key fn keymap)
      (setq key (pop bindings)
            fn (pop bindings)))
    (lambda ()
      (interactive)
      (let ((exit (set-temporary-overlay-map keymap t (lambda () (when quit (quit-window))))))
        (when quit
          (bind-key "q" (cmd! (funcall exit)) keymap))))))
#+end_src

And one that enters a ~mode~, then turns on the keymap. It turns ~mode~ off again if you hit a key not in the map.

#+begin_src emacs-lisp
(defun t/micro-state-in-mode (mode after key fn &rest bindings)
  "Micro state that toggles mode and temporarily overlays a new key map, kinda like hydra"
  (let ((keymap (make-sparse-keymap)))
    (while key
      (bind-key key fn keymap)
      (setq key (pop bindings)
            fn (pop bindings)))
    (lambda ()
      (interactive)
      (funcall mode)
      (set-temporary-overlay-map keymap t (lambda nil
                                            (funcall mode -1)
                                            (when after (after)))))))
#+end_src

** Editor

*** Which key

Don't bother waiting

#+begin_src emacs-lisp
(setq which-key-idle-delay 0.1)
#+end_src

*** Evil

I spent so much time with vim, I will probably never give it up.

**** Config

Useful for ~c-e~ followed by ~c-x c-e~ to eval a s-exp. Makes ~cleverparens~ nav commands like ~L~ and ~H~ move across sexps

#+begin_src emacs-lisp
(setq evil-move-beyond-eol t)
#+end_src

Don't use zz and zq for org src editing

#+begin_src emacs-lisp
(after! evil-collection
  (add-to-list 'evil-collection-key-blacklist "ZZ")
  (add-to-list 'evil-collection-key-blacklist "ZQ"))
#+end_src

**** Unbind C-h in evil window bindings

I use ~SPC w h~ instead of ~SPC w C-h~ to move to the left window. ~C-h~ is more useful as =embark-prefix-help-command=, which this falls back to, like in all other keymaps

#+begin_src emacs-lisp
(map! :after evil :map evil-window-map "C-h" nil)
#+end_src

**** Registers

Some macros I once used.

This one makes camelCaseWords into to snake_case_words. Run it with ~@c~

#+begin_src emacs-lisp
(evil-set-register ?c [?: ?s ?/ ?\\ ?\( ?\[ ?a ?- ?z ?0 ?- ?9 ?\] ?\\ ?\) ?\\ ?\( ?\[ ?A ?- ?Z ?0 ?- ?9 ?\] ?\\ ?\) ?/ ?\\ ?1 ?_ ?\\ ?l ?\\ ?2 ?/ ?g])
#+end_src

*** Macros

A useful macro one for testing stuff out

#+begin_src emacs-lisp
(defmacro comment (&rest ignore)
  nil)

(comment
 (funcall (t/micro-state nil "m" (cmd! (message "1")))))
#+end_src

*** Embark

#+begin_src emacs-lisp
(map!
 :g "C-," #'embark-act ; global
 :map org-mode-map "C-," #'embark-act
 :map minibuffer-mode-map "C-," #'embark-act)
#+end_src

Prevent =embark-export=, ~C-e~, from being "popupized" by doom's ~:ui popup~ and its ~(popup +all)~ setting.

#+begin_src emacs-lisp
(set-popup-rule! "^*Embark" :ignore t)
#+end_src

#+begin_src emacs-lisp
;; Don't need this? You can C-SPC to preview
;;(add-hook 'completion-list-mode-hook #'consult-preview-at-point-mode)
#+end_src

Embark improves prefix help commands, e.g. ~C-c C-h~, by showing auto complete that is fuzzy searchable.

*** Vertico

~C-a c-k~ is so engrained in my fingers, I need it everywhere. ~C-a~ seems to work out of the box.

#+begin_src emacs-lisp
(after! vertico
  (map! :map vertico-map
        :g "C-k" 'kill-line))
#+end_src

Exclude stuff from ~+default/search-project~ by placing excludes in [[file:~/.rgignore][~/.rgignore]]

*** Dired

#+begin_src emacs-lisp
(after! dired
  (add-hook 'dired-mode-hook 'dired-subtree-toggle)
  (add-hook 'dired-mode-hook 'dired-hide-details-mode))
#+end_src

#+begin_src emacs-lisp
(after! dired
  (map!
   :map dired-mode-map
   "C-k" 'dired-kill-subdir
   "<backspace>" 'dired-kill-subdir
   "M-<down>" (cmd! (dired-find-alternate-file))
   "M-<up>" (cmd! (find-alternate-file ".."))))
#+end_src

*** Customize

Doom doesnt use the customize interface. It is useful nonetheless for experimenting with face colors etc

#+begin_src emacs-lisp
(set-popup-rule! "^*Customize" :ignore t)
#+end_src

*** STARTED Directory sidebar

A diy directory sidebar using dired. Refactored as suggested in https://www.reddit.com/r/emacs/comments/nlefvx/weekly_tips_and_tricks/.

#+begin_src emacs-lisp
(defun t-toggle-sidebar ()
  (interactive)
  (unless t-sidebar-mode (t-sidebar-mode 1))
  (let* ((sidebar-buffer (get-buffer "*sidebar*"))
         (sidebar-displayed
          (and sidebar-buffer
               (get-buffer-window sidebar-buffer))))
    (if sidebar-displayed
        (kill-buffer sidebar-buffer)
      ;; buffer may exist without being displayed
      (and (get-buffer "*sidebar*") (kill-buffer "*sidebar*"))
      ;; do not uses directly dired to no trigger display-buffer !
      ;; so if you have special rules for dired, they are not executed for the sidebar.
      ;; instead we create it in the background and display it only when it is renamed.
      (with-current-buffer (dired-noselect ".")
        ;; eventually hide details to get a slim version of dired
        (dired-hide-details-mode)
        (rename-buffer "*sidebar*"))
      ;; select it with pop-to-buffer. uses display-buffer otherwise
      ;; or tweak the 'select property of display-buffer-alist
      (pop-to-buffer "*sidebar*"))))

;; at this point using a mode is just about being listed
;; in the list of modes ... you can totally skip it and only
;; keep the tweaks of display-buffer-alist I think or melt the
;; previous function in the mode definition
(define-minor-mode t-sidebar-mode
  "A dired sidebar."
  :global t
  :init-value nil
  :lighter ""
  (if t-sidebar-mode
      (add-to-list 'display-buffer-alist
                   '("\\*sidebar\\*"
                     (display-buffer-in-side-window)
                     (side . left)
                     (window-height . fit-window-to-buffer)
                     (body-function . (lambda (window)
                                        ;; display-buffer-in-side-window already set
                                        ;; set-window-dedicated-p to 'side but you ask
                                        ;; for a stronger dedication
                                        ;;TODO torgeir try without this, its annoying when moving up the directory tree
                                        ;; which throws you to a new buffer
                                        ;;(set-window-dedicated-p window t)

                                        ;; this is a know bug, so necessary yes.
                                        (add-hook 'kill-buffer-hook #'delete-window nil t)))
                     (window-parameters . ((no-other-window . t)))))
    (setq display-buffer-alist
          (delq (assoc "\\*sidebar\\*" display-buffer-alist)
                display-buffer-alist))))
#+end_src

~(popup +all)~ steals this, so move it to the left

#+begin_src emacs-lisp
(set-popup-rule! "^*sidebar*"
  :side 'left
  :ttl nil ;; don't kill it on C-g
  :parameters '((slot . -1)
                (window-parameters . ((no-other-window . t)))))
#+end_src

*** Multiple cursors

#+begin_src emacs-lisp
(after! evil
  (defun t/mc-skip-prev ()
    (interactive)
    (evil-multiedit-toggle-or-restrict-region)
    (evil-multiedit-match-and-prev))

  (defun t/mc-skip-next ()
    (interactive)
    (evil-multiedit-toggle-or-restrict-region)
    (evil-multiedit-match-and-next)))
#+end_src

Make cursor follow matches so ~m-n~ or ~m-p~ can be used to skip matches easily, depending on what direction you are moving in.

#+begin_src emacs-lisp
(after! evil
  (setq evil-multiedit-follow-matches t)
  (map!
   :after evil
   :mode evil-multiedit-mode
   ;; for some reason m-j does not work, use m-n and m-p instead
   :n "M-n"   #'t/mc-skip-next
   :n "M-p"   #'t/mc-skip-prev

   ;; don't clash with ~evil-cp-delete-sexp~, require visual mode for multi edit
   :mode emacs-lisp-mode
   :v "M-d" 'evil-multiedit-match-symbol-and-next))
#+end_src

Restores a lost multiedit selection.

#+begin_src emacs-lisp
(map!
 :g "C-M-r" 'evil-multiedit-restore)
#+end_src

Multiedit calls iedit which is missing all-caps in emacs 29.

#+begin_src elisp
(when (version< "29.0" emacs-version)
  (defun all-caps (smtn)
    (upper smtn)))
#+end_src

*** Font

#+begin_quote
;; Doom exposes five (optional) variables for controlling fonts in Doom:
;;
;; - `doom-font' -- the primary font to use
;; - `doom-variable-pitch-font' -- a non-monospace font (where applicable)
;; - `doom-big-font' -- used for `doom-big-font-mode'; use this for
;;   presentations or streaming.
;; - `doom-unicode-font' -- for unicode glyphs
;; - `doom-serif-font' -- for the `fixed-pitch-serif' face
;;
;; See 'C-h v doom-font' for documentation and more examples of what they
;; accept. For example:
;;
#+end_quote

#+begin_quote
JetBrains Mono:pixelsize=16:foundry=JB:weight=medium:slant=normal:width=normal:spacing=100:scalable=true
#+end_quote

#+begin_src emacs-lisp
(setq doom-font (font-spec :family "JetBrains Mono" :size 14 :weight 'medium :slant 'normal :width 'normal)
      doom-variable-pitch-font (font-spec :family "JetBrains Mono" :size 14 :weight 'medium :slant 'normal :width 'normal)
      doom-big-font (font-spec :family "JetBrains Mono" :size 20 :weight 'medium :slant 'normal :width 'normal)
      ;; font resize increments
      doom-font-increment 1)
#+end_src

To list available fontsets, do

#+begin_src emacs-lisp
(comment
 (call-interactively 'describe-font))
#+end_src

#+begin_quote
;; If you or Emacs can't find your font, use 'M-x describe-font' to look them
;; up, `M-x eval-region' to execute elisp code, and 'M-x doom/reload-font' to
;; refresh your font settings. If Emacs still can't find your font, it likely
;; wasn't installed correctly. Font issues are rarely Doom issues!
#+end_quote

*** Errors

Navigate flycheck errors

#+begin_src emacs-lisp
(map!
 :leader
 (:prefix-map ("e" . "errors")
              (:when t
                :desc "Toggle flycheck"        "t" #'flycheck-mode
                :desc "List errors"            "l" #'flycheck-list-errors
                :desc "Jump to next error"     "n" #'flycheck-next-error
                :desc "Jump to previous error" "N" #'flycheck-previous-error)))
#+end_src

*** Visual line mode

#+begin_src emacs-lisp
(add-hook 'after-init-hook (cmd! (global-visual-line-mode 1)))
(add-hook 'prog-mode-hook  (cmd! (toggle-truncate-lines 1)))
#+end_src

*** Projects

Ignore some extra folders from projectile

#+begin_src emacs-lisp
(after! projectile
  (add-to-list 'projectile-globally-ignored-directories "^\\.log$"))
#+end_src

*** Workspaces

#+begin_src emacs-lisp
(map! :leader "1" '+workspace/switch-to-0)
(map! :leader "2" '+workspace/switch-to-1)
(map! :leader "3" '+workspace/switch-to-2)
(map! :leader "4" '+workspace/switch-to-3)
(map! :leader "5" '+workspace/switch-to-4)
(map! :leader "6" '+workspace/switch-to-5)
(map! :leader "7" '+workspace/switch-to-6)
(map! :leader "8" '+workspace/switch-to-7)
(map! :leader "0" '+workspace/switch-to-final)
#+end_src

*** Themes

There's a lot of good [[file:~/.emacs.d/.local/straight/repos/themes/themes/][doom themes]].

#+begin_src emacs-lisp
(setq doom-theme 'doom-moonlight)
#+end_src

#+begin_src emacs-lisp
(defun t/cycle-theme ()
  (interactive)
  (cl-case doom-theme
    (doom-laserwave (load-theme 'doom-moonlight))
    (doom-moonlight (load-theme 'doom-vibrant))
    (doom-vibrant (load-theme 'doom-flatwhite))
    (doom-flatwhite (load-theme 'doom-nord))
    (t (load-theme 'doom-laserwave)))
  (message "Theme: %s" doom-theme))
(map! :leader "t t" #'t/cycle-theme)
#+end_src

**** Line numbers

#+begin_src emacs-lisp
;; This determines the style of line numbers in effect. If set to `nil', line
;; numbers are disabled. For relative line numbers, set this to `relative'.
(setq display-line-numbers-type nil)
#+end_src

**** Rainbow mode

***** Rainbow mode in prog modes

#+begin_src emacs-lisp
(add-hook! '(prog-mode-hook css-mode-hook html-mode-hook) 'rainbow-mode)
#+end_src

***** Color parens uniformly

#+begin_src emacs-lisp
(custom-set-faces!
  '(show-paren-match :background nil :foreground "yellow" :weight bold)
  '(rainbow-delimiters-depth-1-face :foreground "DeepPink4" :overline nil :underline nil)
  '(rainbow-delimiters-depth-2-face :foreground "DeepPink3" :overline nil :underline nil)
  '(rainbow-delimiters-depth-3-face :foreground "DeepPink2" :overline nil :underline nil)
  '(rainbow-delimiters-depth-4-face :foreground "DeepPink1" :overline nil :underline nil)
  '(rainbow-delimiters-depth-5-face :foreground "maroon4" :overline nil :underline nil)
  '(rainbow-delimiters-depth-6-face :foreground "maroon3" :overline nil :underline nil)
  '(rainbow-delimiters-depth-7-face :foreground "maroon2" :overline nil :underline nil)
  '(rainbow-delimiters-depth-8-face :foreground "maroon1" :overline nil :underline nil)
  '(rainbow-delimiters-depth-9-face :foreground "VioletRed3" :overline nil :underline nil)
  '(rainbow-delimiters-depth-10-face :foreground "VioletRed2" :overline nil :underline nil)
  '(rainbow-delimiters-depth-11-face :foreground "VioletRed1" :overline nil :underline nil)
  '(rainbow-delimiters-unmatched-face :foreground "Red" :overline nil :underline nil))
#+end_src

*** Frame

Show the buffer and the file

#+begin_src emacs-lisp
(setq frame-title-format "%b (%f)")
#+end_src

*** Jump around

Some of these, like ~SPC j c~ works across windows when prefixed with ~C-u~.

#+begin_src emacs-lisp
(map!
 :leader
 (:prefix-map ("j" . "jump")
  (:when t
   :desc "Jump to window"      "w" #'ace-window
   :desc "Jump to line"        "l" #'avy-goto-line
   :desc "org: Jump to header" "h" #'avy-org-goto-heading-timer
   :desc "Jump to char"        "c" #'avy-goto-char-2
   :desc "Jump to char"        "C" #'avy-goto-char)))
#+end_src

**** STARTED Avy tweaks

#+begin_src emacs-lisp
(after! magit
  (set-face-attribute 'magit-diff-hunk-heading nil :background "#513d5b" :foreground "#07010E")
  (set-face-attribute 'magit-diff-hunk-heading-highlight nil :background "#ED60BA" :foreground "#01010E" :weight 'bold)
  (set-face-attribute 'magit-diff-revision-summary nil :inherit 'magit-diff-hunk-heading :foreground "#ED60BA"))
#+end_src

#+begin_src emacs-lisp
(after! avy
  (setq avy-keys '(?j ?f ?d ?k ?s ?a)
        avy-timeout-seconds 0.2
        avy-all-windows 'all-frames
        avy-case-fold-search nil
        avy-highlight-first t
        avy-style 'at-full
        avy-background t)

  (let* ((f 'font-lock-keyword-face)
         (b "black")
         (c "yellow"))
    (set-face-attribute 'avy-lead-face nil   :background b :weight 'bold :foreground c)
    (set-face-attribute 'avy-lead-face-0 nil :background b :weight 'bold :foreground c)
    (set-face-attribute 'avy-lead-face-1 nil :background b :weight 'bold :foreground c)
    (set-face-attribute 'avy-lead-face-2 nil :background b :weight 'bold :foreground c)))
#+end_src

*** Smartparens

#+begin_src emacs-lisp
(after! smartparens
  (sp-local-pair 'emacs-lisp-mode "`" "'" :when '(sp-in-docstring-p))
  (sp-use-paredit-bindings))
#+end_src

And some extra for org mode

#+begin_src emacs-lisp
(after! smartparens
  (sp-with-modes 'org-mode
    (sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-at-bol-p) :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
    (sp-local-pair "~" "~" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "<" ">" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "=" "=" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "«" "»")))
#+end_src

Smartparens-mode paredit bindings in org mode messes up M-up and M-down, bring them back.

#+begin_src emacs-lisp
(add-hook! 'org-mode-hook
  (map!
   :map evil-motion-state-local-map
   "M-<up>"    'org-metaup
   "M-<down>"  'org-metadown
   "M-S-<right>" 'org-shiftmetaright
   "M-S-<left>" 'org-shiftmetaleft))
#+end_src

Bring back ~C-k~ in the minibuffer. Overrides [[file:~/.emacs.d/modules/config/default/+evil-bindings.el::map! :map (evil-ex-completion-map evil-ex-search-keymap][+evil-bindings.el]].

#+begin_src emacs-lisp
(map! :map (evil-ex-completion-map evil-ex-search-keymap)
      :gi "C-k" #'kill-line)
(define-key!
  :keymaps +default-minibuffer-maps
  "C-k" #'kill-line)
#+end_src

**** Wrap around

Support wrapping sexps by holding super, both in normal mode and insert mode, from the front and the back of expressions.

#+begin_src emacs-lisp
(map! :map smartparens-mode-map
      ;; literally S-s-8 on a norwegian mac keyboard
      :n "s-(" (cmd! (evil-emacs-state nil)
                     (sp-wrap-with-pair "\(")
                     (evil-normal-state nil))
      :i "s-(" (cmd! (sp-wrap-with-pair "\("))

      ;; literally S-s-MetaRight-8 on my norwegian mac keyboard
      :n "s-{" (cmd! (evil-emacs-state nil)
                     (sp-wrap-with-pair "\{")
                     (evil-normal-state nil))
      :i "s-{" (cmd! (sp-wrap-with-pair "\{"))

      ;; literally S-MetaRight-8 on my norwegian mac keyboard
      :n "s-[" (cmd! (evil-emacs-state nil)
                     (sp-wrap-with-pair "\[")
                     (evil-normal-state nil))
      :i "s-[" (cmd! (sp-wrap-with-pair "\["))

      ;; literally S-s-9 on a norwegian mac keyboard
      :n "s-)" (cmd! (evil-emacs-state nil)
                     (backward-sexp)
                     (sp-wrap-with-pair "\(")
                     (forward-sexp)
                     (evil-normal-state nil))
      :i "s-)" (cmd! (backward-sexp)
                     (sp-wrap-with-pair "(")
                     (forward-sexp))

      ;; literally S-s-MetaRight-9 on my norwegian mac keyboard
      :n "s-}" (cmd! (evil-emacs-state nil)
                     (backward-sexp)
                     (sp-wrap-with-pair "\{")
                     (forward-sexp)
                     (evil-normal-state nil))
      :i "s-}" (cmd! (backward-sexp)
                     (sp-wrap-with-pair "\{")
                     (forward-sexp))

      ;; literally S-MetaRight-9 on my norwegian mac keyboard
      :n "s-]" (cmd! (evil-emacs-state nil)
                     (backward-sexp)
                     (sp-wrap-with-pair "\[")
                     (forward-sexp)
                     (evil-normal-state nil))
      :i "s-]" (cmd! (backward-sexp)
                     (sp-wrap-with-pair "\[")
                     (forward-sexp)))
#+end_src

*** Distraction free / Zen
**** Writeroom

A _really global_ global writeroom mode. The function is redefined such that if writeroom-major-modes is nil, writeroom-mode is activated in ALL buffers.

#+begin_src emacs-lisp
(setq writeroom-major-modes nil)
(after! writeroom-mode
  (defun turn-on-writeroom-mode ()
    (when (or (not writeroom-major-modes)
              (apply 'derived-mode-p writeroom-major-modes))
      (writeroom-mode 1))))
#+end_src

The [[https://docs.doomemacs.org/latest/modules/ui/zen/][doom default text scale of 2]] is a bit heavy

#+begin_src emacs-lisp
(setq +zen-text-scale 1.1)
#+end_src

And screens are big, so a bit more space for text is nice.

#+begin_src emacs-lisp
(setq writeroom-width 120)
#+end_src

** Dotfiles

Highlight dotfiles that are sourced from the shell in ~shell-mode~ based on their file location.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist (cons (concat "^" (t/user-file "dotfiles/source")) 'shell-mode))
#+end_src

** Keybindings

- [[file:~/.emacs.d/modules/editor/evil/config.el::(map! :v "@" #'+evil:apply-macro][Doom editor keybindings]]
- [[file:~/.emacs.d/modules/config/default/+evil-bindings.el::map! :map (evil-ex-completion-map evil-ex-search-keymap][+evil-bindings.el]]

#+begin_src emacs-lisp
(map!
 :n "s-0" nil
 "s-0" #'doom/reset-font-size
 "s-+" #'doom/increase-font-size
 "s--" #'doom/decrease-font-size

 "s-?" (lambda () (interactive) (text-scale-increase 1))
 "s-_" (lambda () (interactive) (text-scale-decrease 1))
 "s-=" (lambda () (interactive) (text-scale-set 0))

 "s-d" #'t/split-window-right-and-move-there-dammit
 "s-D" #'t/split-window-below-and-move-there-dammit

 "s-M-<up>" 'evil-window-up
 "s-M-<right>" 'evil-window-right
 "s-M-<down>" 'evil-window-down
 "s-M-<left>" 'evil-window-left

 "M-n" 'forward-paragraph
 "M-p" 'backward-paragraph

 ;; g = global
 :i "C-d" 'delete-char

 "s-k" 'previous-buffer
 "s-j" 'next-buffer
 "s->" 'next-multiframe-window
 "s-<" 'previous-multiframe-window
 "s-<left>" 't/smart-beginning-of-line
 "s-<right>" 'end-of-line

 "C-." 't/hippie-expand-no-case-fold
 "C-a" 't/smart-beginning-of-line
 :m "C-e" 'end-of-line

 "s-n" 'make-frame
 "s-s" 'save-buffer
 "s-w" #'t/delete-frame-or-hide-last-remaining-frame

 ;; op -- :leader :desc "Toggle treemacs" "f L" #'+treemacs/toggle
 ;; oO -- :leader :desc "Open folder" "p o" #'t/open-in-desktop

 :leader :desc "Browse" "o e" #'eww
 :leader :desc "Locate" "f L" #'consult-locate
 :leader :desc "Toggle directory sidebar" "f l" #'t-toggle-sidebar

 :leader :desc "Soft line wrapping" "t w" #'visual-line-mode
 :leader :desc "Show whitespace" "t W" #'whitespace-mode

 :leader :desc "Show calendar" "o c" #'calendar
 :leader :desc "Show home" "o h" #'(lambda () (interactive) (find-file (t/user-dropbox-folder "org/home.org.gpg")))
 :leader :desc "Show saga" "o s" #'(lambda () (interactive) (find-file (t/user-dropbox-folder "org/saga.org.gpg")))
 :leader :desc "Browse at point" "o b" #'t/browse-url-at-point
 :leader :desc "Open rss" "o S" #'=rss
 :leader :desc "Open Intellij" "o i" #'t/open-in-intellij
 :leader :desc "Search the web" "s w" #'consult-web-search
 :leader :desc "Eval and replace" "m e R" #'t/eval-and-replace
 :leader :desc "Toggle transparency" "t T" #'t/transparency
 :leader :desc "Toggle writeroom" "t d" #'global-writeroom-mode
 :leader :desc "Flip frame" "w f" #'rotate-frame
 :leader :desc "Rotate frame" "w r" #'rotate-frame-anticlockwise
 :leader :desc "Rotate frame clockwise" "w R" #'rotate-frame-clockwise
 :leader :desc "Debug on error" "t D" #'toggle-debug-on-error
 :leader :desc "Toggle focus mode" "t f" #'focus-mode
 :leader :desc "Toggle flycheck" "t F" #'flycheck-mode
 :leader :desc "Close window unconditionally" "w d" #'delete-window
 :leader :desc "Projectile dired" "p d" #'t/projectile-dired
 :leader :desc "Projectile git" "p g" #'t/projectile-magit-status
 :leader :desc "Projectile pulls" "p P" #'t/projectile-visit-git-link-pulls
 :leader :desc "Twitter" "o w" #'=twitter
 :leader :desc "Open scratch buffer" "b s" #'doom/open-scratch-buffer
 :leader :desc "Toggle dedication" "t e" #'t/toggle-dedicated-window

 :leader :desc "Previous occurrence" "h p" #'highlight-symbol-prev
 :leader :desc "Previous occurrence" "h N" #'highlight-symbol-prev
 :leader :desc "Next occurrence" "h n" #'highlight-symbol-next)
 #+end_src

Be explicit about when deleting workspaces

#+begin_src emacs-lisp
(after! (:and evil persp-mode)
  (define-key! persp-mode-map
    [remap delete-window] #'delete-window
    [remap evil-window-delete] #'delete-window))

(map!
 :map doom-leader-workspace-map
 :leader :desc "Next workspace" "TAB j" '+workspace:switch-next
 :leader :desc "Previous workspace" "TAB k" '+workspace:switch-previous
 :leader :desc "Swap next" "TAB J" '+workspace/swap-right
 :leader :desc "Swap previous" "TAB K" '+workspace/swap-left)
#+end_src

Hide the last frame on os x instead of nuking it

#+begin_src emacs-lisp
(map! :leader "q f" 't/delete-frame-or-hide-last-remaining-frame)
#+end_src

Prevent drag-stuff-mode from messing things up

#+begin_src emacs-lisp
(map!
 ;; that's irritating
 :after drag-stuff-mode
 :map drag-stuff-mode-map
 "<M-up>"    #'drag-stuff-up ;; messes up org mode
 "<M-down>"  #'drag-stuff-down ;; messes up org mode
 ;; :ni "<M-left>"  #'evil-backward-word-begin
 ;; :ni "<M-right>" #'evil-forward-word-begin
 )
#+end_src

** Help

One help shortcut, everywhere.

#+begin_src emacs-lisp
(map! :leader :n "h h" #'helpful-at-point)
#+end_src

Keep them on the side for some more room.

#+begin_src emacs-lisp
(set-popup-rule! "^*info" :side 'right :width 82)
(set-popup-rule! "^*help" :side 'right :width 82)
#+end_src

*** Motions

Make helpful buffers more navigable by removing doom popup's /dedication/. This makes ~q~ fall back to the previous help buffer after a help link click that made you navigate to the next help topic.

#+begin_src emacs-lisp
(advice-add
 #'push-button
 :after (cmd!
         (set-window-dedicated-p (selected-window) nil)
         (set-window-parameter (selected-window) 'no-delete-other-windows nil)))
#+end_src

*** Info mode

#+begin_src emacs-lisp
(after! info
  (map!
   :map Info-mode-map
   "M-n" #'forward-paragraph
   "M-p" #'backward-paragraph))
#+end_src

**** Motions

Motion keys for info mode.

#+BEGIN_SRC emacs-lisp :results silent
(after! evil
  (after! info
         (evil-define-key 'normal Info-mode-map (kbd "H") 'Info-history-back)
         (evil-define-key 'normal Info-mode-map (kbd "L") 'Info-history-forward)
         (unbind-key (kbd "h") 'Info-mode-map)
         (unbind-key (kbd "l") 'Info-mode-map)))
#+END_SRC

** Org
*** Org settings

#+begin_src emacs-lisp
(after! org

  (add-hook! 'org-mode-hook 'hl-todo-mode)
  (add-hook! 'org-mode-hook 'evil-cleverparens-mode)

  (defun t/open-prev-heading ()
    (interactive)
    (let ((was-narrowed (buffer-narrowed-p)))
      (when was-narrowed (widen))
      (when (org-at-heading-p)
        (outline-hide-sublevels (org-outline-level)))
      (org-previous-visible-heading 1)
      (outline-show-subtree)
      (when was-narrowed (org-narrow-to-subtree))))

  (defun t/open-next-heading ()
    (interactive)
    (let ((was-narrowed (buffer-narrowed-p)))
      (when was-narrowed (widen))
      (when (org-at-heading-p)
        (outline-hide-sublevels (org-outline-level)))
      (org-next-visible-heading 1)
      (outline-show-subtree)
      (when was-narrowed (org-narrow-to-subtree))))

  ;; like in normal org, not like in doom
  (map! :after evil-org
        :map evil-org-mode-map
        :ni "C-<return>" #'org-insert-heading-respect-content

        ;; bring back deleting characters from insert in org mode
        :i "C-d" nil

        :map org-mode-map
        :ni "C-c C-p" #'t/open-prev-heading
        :ni "C-c C-n" #'t/open-next-heading)

  ;; Include gpg files in org agenda
  (unless (string-match-p "\\.gpg" org-agenda-file-regexp)
    (setq org-agenda-file-regexp
          (replace-regexp-in-string "\\\\\\.org" "\\\\.org\\\\(\\\\.gpg\\\\)?"
                                    org-agenda-file-regexp)))

  (defun t/org-capture-chrome-link-template (&optional &rest args)
    "Capture current frontmost tab url from chrome."
    (concat "* TODO %? :url:\n\n" (t/grab-chrome-url)))

  (defun t/org-capture-elfeed-link-template (&optional &rest args)
    "Capture open elfeed post with url."
    (concat "* TODO %? :url:%^G\n%i\n" (elfeed-entry-link elfeed-show-entry)))

  (setq org-tags-column -60
        org-support-shift-select t   ; shift can be used to mark multiple lines
        org-special-ctrl-k t         ; don't clear tags, etc
        org-special-ctrl-a/e t       ; don't move past ellipsis on c-e
        org-agenda-skip-scheduled-if-done t
        org-default-notes-file (expand-file-name "~/Dropbox/org/home.org.gpg")
        org-log-done 'time           ; log when todos are completed
        org-log-redeadline 'time     ; log when deadline changes
        org-log-reschedule 'time     ; log when schedule changes
        org-reverse-note-order t     ; newest notes first
        org-return-follows-link t    ; go to http links in browser
        org-todo-keywords '((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d)" "CANCELLED(c)"))))
#+end_src

*** Async source code blocks

Make it possible to use the header argument ~:async true~ for async execution of begin_src code blocks.

#+begin_src emacs-lisp
(after! org
  (require 'ob-async))
#+end_src

*** Agenda

**** Custom commands

Org agenda customizations

#+begin_src emacs-lisp
(defun t/org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))

(defun t/org-agenda-todo-type (name)
  `((org-agenda-remove-tags t)
    (org-agenda-sorting-strategy '(tag-up priority-down))
    (org-agenda-todo-keyword-format "")
    (org-agenda-overriding-header ,name)))


(defun t/org-agenda-pri-a (&rest tags)
  (string-join (-map (lambda (tag) (format "%s+PRIORITY=\"A\"" tag)) tags) "|"))

(defun t/org-agenda-pri (header &rest tags)
  (list (apply 't/org-agenda-pri-a tags)
        `((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
          (org-agenda-overriding-header ,header))))

(defun t/org-agenda-day (tags)
  (list tags `((org-agenda-span 'day)
               (org-agenda-ndays-to-span 1)
               (org-agenda-time-grid nil)
               (org-agenda-tag-filter-preset ,tags))))

(defun t/org-agenda-not-pri (header tags skip)
  (list tags `((org-agenda-overriding-header ,header)
               (org-agenda-skip-function '(or (t/org-skip-subtree-if-priority ?A)
                                              (org-agenda-skip-if nil (quote ,skip)))))))

(defun t/org-agenda-todos (header tags)
  (t/org-agenda-not-pri header tags '(scheduled deadline)))

(defun t/org-agenda-todos-scheduled (header tags)
  (t/org-agenda-not-pri header tags '(notscheduled deadline)))

(defun t/org-day-summary (&rest tags)
  `((tags ,@(apply 't/org-agenda-pri (append (list "Pri") tags)))
    (agenda ,@(t/org-agenda-day (string-join tags "|")))
    (tags-todo ,@(t/org-agenda-todos "Todo" (string-join tags "|")))
    (tags-todo ,@(t/org-agenda-todos-scheduled "Scheduled todo" (string-join tags "|")))))

(defun t/org-agenda-read ()
  '(tags-todo "book|read|twitter|pocket" ((org-agenda-overriding-header "Read"))))
#+end_src

And some custom agenda shortcuts

#+begin_src emacs-lisp
(setq org-agenda-custom-commands `(("n" "Agenda and all TODOs" ((agenda "") (alltodo "")))
                                   ("m" tags-todo "serie|film")
                                   ("e" tags-todo "emacs")
                                   ("r" tags-todo "book|read|twitter|pocket")
                                   ("v" tags-todo "video")
                                   ("T" alltodo)
                                   ("C" todo "DONE" ,(t/org-agenda-todo-type "DONE"))
                                   ("t" todo "TODO" ,(t/org-agenda-todo-type "TODO"))
                                   ("b" todo "STARTED" ,(t/org-agenda-todo-type "STARTED"))
                                   ("c" todo "CANCELLED" ,(t/org-agenda-todo-type "CANCELLED"))
                                   ))
#+end_src

**** Clock

#+begin_src emacs-lisp
(defun t/org-clock-start () (interactive) (org-todo "STARTED"))
(defun t/org-clock-stop () (interactive) (org-todo))
(advice-remove 'org-clock-in 't/org-clock-start)
(advice-remove 'org-clock-out 't/org-clock-stop)
(advice-add 'org-clock-in :after 't/org-clock-start)
(advice-add 'org-clock-out :after 't/org-clock-stop)
#+end_src

*** Keybindings

Extensions of some of the [[file:~/.emacs.d/modules/lang/org/config.el::(map! :map org-mode-map][Doom org mode map bindings]].

~SPC g a~ seems more reasonable than ~SPC g G~

#+begin_src emacs-lisp
(map! :map org-mode-map
      :localleader "g a" #'consult-org-agenda)
#+end_src

Widen

#+begin_src emacs-lisp
(map!
 :map org-mode-map
 :leader :desc "Widen" "m s w" 'widen
 :leader :desc "Narrow to subtree" "m s n" 'org-narrow-to-subtree)
#+end_src

Save from agenda

#+begin_src emacs-lisp
(map! :map org-agenda-mode-map
      "s-s" #'org-save-all-org-buffers)
#+end_src

*** Colors

#+begin_src emacs-lisp
(after! org
  (set-face-attribute 'org-todo nil :foreground "#94fFe4" :weight 'bold))
#+end_src

*** Refile

Save org mode buffers after refile

#+begin_src emacs-lisp
(defadvice org-refile (after t/after-org-refile activate)
  (org-save-all-org-buffers))
#+end_src

*** Tables

#+begin_src emacs-lisp
(after! evil
  (when (boundp 'org-evil-table-mode-map)
    (map!
     :map org-evil-table-mode-map
     "M-S-<left>" 'org-table-delete-column
     "M-S-<right>" 'org-table-insert-column)))
#+end_src

*** Hugo capture template

#+begin_src emacs-lisp
(after! org
  (with-eval-after-load 'org-capture
    (defun org-hugo-new-subtree-post-capture-template ()
      "Returns `org-capture' template string for new Hugo post.
See `org-capture-templates' for more information.
https://ox-hugo.scripter.co/doc/org-capture-setup/"
      (let* ((title (read-from-minibuffer "Post Title: "))
             (fname (org-hugo-slug title)))
        (mapconcat #'identity
                   `(,(concat "* TODO " title)
                     ":PROPERTIES:"
                     ,(concat ":EXPORT_FILE_NAME: " fname)
                     ":END:" "%?\n")
                   "\n")))))
#+end_src

*** Structure templates

Remove the ~s~ mapping for source code blocks.

#+begin_src emacs-lisp
(after! org
  (setq org-structure-template-alist (remove '("s" "src") org-structure-template-alist)))
#+end_src

Replace it with ~ss~ (its faster than the default ~s ~) so we can add some more along side it.

#+begin_src emacs-lisp
(after! org
  (add-to-list 'org-structure-template-alist (cons "ss" "src"))
  (add-to-list 'org-structure-template-alist (cons "se" "src emacs-lisp"))
  (add-to-list 'org-structure-template-alist (cons "sp" "src python"))
  (add-to-list 'org-structure-template-alist (cons "sh" "src shell")))
#+end_src

Don't popupize the org code block editor with doom's popup framework, so it opens split wherever it fits like it is by default.

#+begin_src emacs-lisp
(after! org
  (set-popup-rule! "^*Org Src" :ignore t))
#+end_src

*** Capture templates

#+begin_src emacs-lisp
(after! org
  (setq org-capture-templates
        `(("t" "Task" entry (file+olp org-default-notes-file "tasks") "* TODO %? \n\n%i\n\n" :prepend t :empty-lines-after 1)
          ("s" "Saga" entry (file+olp ,(t/user-dropbox-folder "org/saga.org.gpg") "Tasks") "* TODO %? \n\n%i" :prepend t :empty-lines-after 1)
          ("b" "bekk" entry (file+olp ,(t/user-dropbox-folder "org/bekk.org.gpg") "Tasks") "* TODO %? \n\n%i" :prepend t :empty-lines-after 1)
          ;;("d" "Shared calendar event" entry (file ,(t/user-dropbox-folder "org/gcal/delt.org.gpg")) "* %?\n" :prepent t)
          ("l" "Link" entry (file+olp org-default-notes-file "Tasks") "* TODO %? %^G\n\nLink: %a" :prepend t :empty-lines-after 1)
          ("f" "File" entry (file+olp org-default-notes-file "Tasks") "* TODO %? %^G\n\n%i%a\n\n" :prepend t :empty-lines-after 1)
          ("c" "Chrome location" entry (file+olp org-default-notes-file "Tasks") (function t/org-capture-chrome-link-template) :prepend t :empty-lines-after 1)
          ("e" "Elfeed location" entry (file+olp org-default-notes-file "Tasks") (function t/org-capture-elfeed-link-template) :prepend t :empty-lines-after 1)
          ("p" "Post" entry (file+olp "~/Code/posts/content-org/blog.org" "Drafts") (function org-hugo-new-subtree-post-capture-template))
          ;; ("T" "Personal todo" entry (file+headline +org-capture-todo-file "Inbox") "* %?\n %i\n %a" :prepend t)
          ;; ("j" "Journal" entry (file+olp+datetree +org-capture-journal-file) "* %U %?\n %i\n %a" :prepend t)
          ;; ("n" "Personal notes" entry (file+headline +org-capture-notes-file "Inbox") "* %u %?\n %i\n %a" :prepend t)
          ;; ("p" "Templates for projects") ("pt" "Project-local todo" entry (file+headline +org-capture-project-todo-file "Inbox") "* TODO %?\n %i\n %a" :prepend t)
          ;; ("pn" "Project-local notes" entry (file+headline +org-capture-project-notes-file "Inbox") "* %U %?\n %i\n %a" :prepend t)
          ;; ("pc" "Project-local changelog" entry (file+headline +org-capture-project-changelog-file "Unreleased") "* %U %?\n %i\n %a" :prepend t)
          ;; ("o" "Centralized templates for projects")
          ;; ("ot" "Project todo" entry #'+org-capture-central-project-todo-file "* TODO %?\n %i\n %a" :heading "Tasks" :prepend nil)
          ;; ("on" "Project notes" entry #'+org-capture-central-project-notes-file "* %U %?\n %i\n %a" :heading "Notes" :prepend t)
          ;; ("oc" "Project changelog" entry #'+org-capture-central-project-changelog-file "* %U %?\n %i\n %a" :heading "Changelog" :prepend t)
          )))
#+end_src

*** Text Objects
**** evil-org-outer-subtree

#+BEGIN_SRC emacs-lisp :results silent
(after! evil
  (evil-define-text-object evil-org-outer-subtree (count &optional beg end type)
    "An Org subtree.  Uses code from `org-mark-subtree`"
    :type line
    (save-excursion
      ;; get to the top of the tree
      (org-with-limited-levels
       (cond ((org-at-heading-p) (beginning-of-line))
             ((org-before-first-heading-p) (user-error "Not in a subtree"))
             (t (outline-previous-visible-heading 1))))

      (cl-decf count)
      (when count (while (and (> count 0) (org-up-heading-safe)) (cl-decf count)))

      ;; extract the beginning and end of the tree
      (let ((element (org-element-at-point)))
        (list (org-element-property :end element)
              (org-element-property :begin element))))))
#+END_SRC

**** evil-org-inner-subtre

#+BEGIN_SRC emacs-lisp :results silent
(after! evil
  (evil-define-text-object evil-org-inner-subtree (count &optional beg end type)
    "An Org subtree, minus its header and concluding line break.  Uses code from `org-mark-subtree`"
    :type line
    (save-excursion
      ;; get to the top of the tree
      (org-with-limited-levels
       (cond ((org-at-heading-p) (beginning-of-line))
             ((org-before-first-heading-p) (user-error "Not in a subtree"))
             (t (outline-previous-visible-heading 1))))

      (cl-decf count)
      (when count (while (and (> count 0) (org-up-heading-safe)) (cl-decf count)))

      ;; extract the beginning and end of the tree
      (let* ((element (org-element-at-point))
             (begin (save-excursion
                      (goto-char (org-element-property :begin element))
                      (next-line)
                      (point)))
             (end (save-excursion
                    (goto-char (org-element-property :end element))
                    (backward-char 1)
                    (point))))
        (list end begin)))))
#+END_SRC

**** evil-org-outer-item

#+BEGIN_SRC emacs-lisp :results silent
(after! evil
  (evil-define-text-object evil-org-outer-item (count &optional beg end type)
    :type line
    (let* ((struct (org-list-struct))
           (begin (org-list-get-item-begin))
           (end (org-list-get-item-end (point-at-bol) struct)))
      (if (or (not begin) (not end))
          nil
        (list begin end)))))
#+END_SRC

**** evil-org-inner-item

#+BEGIN_SRC emacs-lisp :results silent
(after! evil
  (evil-define-text-object evil-org-inner-item (count &optional beg end type)
    (let* ((struct (org-list-struct))
           (begin (progn (goto-char (org-list-get-item-begin))
                         (forward-char 2)
                         (point)))
           (end (org-list-get-item-end-before-blank (point-at-bol) struct)))
      (if (or (not begin) (not end))
          nil
        (list begin end)))))
#+END_SRC

**** Bind them

#+BEGIN_SRC emacs-lisp :results silent
(define-key evil-outer-text-objects-map "h" 'evil-org-outer-subtree)
(define-key evil-inner-text-objects-map "h" 'evil-org-inner-subtree)
(define-key evil-outer-text-objects-map "*" 'evil-org-outer-subtree)
(define-key evil-inner-text-objects-map "*" 'evil-org-inner-subtree)
(define-key evil-outer-text-objects-map "i" 'evil-org-outer-item)
(define-key evil-inner-text-objects-map "i" 'evil-org-inner-item)
(define-key evil-outer-text-objects-map "-" 'evil-org-outer-item)
(define-key evil-inner-text-objects-map "-" 'evil-org-inner-item)
#+END_SRC

** Reading
*** Fast

I never really got into to this.

#+begin_src emacs-lisp
(defun t/spray-micro-state (&optional after)
  (t/micro-state-in-mode
   'spray-mode
   after
   "s" 'spray-slower
   "f" 'spray-faster
   "SPC" 'spray-start/stop
   "b" 'spray-backward-word
   "w" 'spray-forward-word
   "<left>" 'spray-backward-word
   "<right>" 'spray-forward-word))

(map! :leader :desc "Toggle spray" "t s" (t/spray-micro-state))

(after! spray
  (setq spray-wpm 720
        spray-height nil)
  (add-hook 'spray-mode-hook #'t/spray-mode-hook)
  (defun t/spray-mode-hook ()
    (setq-local spray-margin-top (truncate (/ (window-height) 2.5)))
    (setq-local spray-margin-left (truncate (/ (window-width) 3.5)))
    (set-face-foreground 'spray-accent-face
                         (face-foreground 'font-lock-keyword-face))))
#+end_src

*** Eww

An elisp web browser.

**** Lookup

Make ~SPC s o~ open in eww first, then use ~&~ to go to the default browser if needed.

#+begin_src emacs-lisp
(setq +lookup-open-url-fn #'eww)
#+end_src

**** Popup size

#+begin_src emacs-lisp
(after! evil
  ;; the original way
  ;;(setf (alist-get 'size (display-buffer-assq-regexp "*eww*" display-buffer-alist nil)) 0.8)
  ;; the doom way
  (set-popup-rule! "^\\*eww*" :side 'bottom :size 0.8))
#+end_src

**** Readability

Enter readable mode automatically, normally available from pressing ~R~ in eww mode.

#+begin_src emacs-lisp
(add-hook 'eww-after-render-hook 'eww-readable)
#+end_src

Eww functions that directly enter the eww readability mode after loading a given url

#+BEGIN_SRC emacs-lisp
(defun t/eww-readable-after-render (status url buffer fn)
  (eww-render status url nil buffer)
  (switch-to-buffer buffer)
  (eww-readable)
  (let ((content (buffer-substring-no-properties (point-min) (point-max))))
    (read-only-mode 0)
    (erase-buffer)
    (insert content)
    (beginning-of-buffer)
    (toggle-truncate-lines -1)
    (when fn (funcall fn))))

(defun t/eww-readable (url &optional fn)
  (interactive "sEnter URL: ")
  (let ((buffer (get-buffer-create "*eww*")))
    (with-current-buffer buffer
      (autoload 'eww-setup-buffer "eww")
      (eww-setup-buffer)
      (url-retrieve url 't/eww-readable-after-render (list url buffer fn)))))
#+END_SRC

**** Images and wrap long lines

#+BEGIN_SRC emacs-lisp
(after! shr
  ;; don't truncate lines in
  (defun shr-fill-text (text) text)
  (defun shr-fill-lines (start end) nil)
  (defun shr-fill-line () nil)

  ;; not too large images
  (setq shr-use-fonts nil
        shr-max-image-proportion 0.6
        shr-ignore-cache t))
#+END_SRC

**** TODO Open from chrome

Opens the frontmost chrome url in eww.

This does not work atm, ~(void-function org-mac-chrome-get-frontmost-url)~.

#+BEGIN_SRC emacs-lisp
(defun t/visit-frontmost-chrome-url-in-eww ()
  "Visit the front-most url of chrome in eww."
  (interactive)
  (eww (t/grab-chrome-url)))
#+END_SRC

**** Hook and keybindings

Some useful eww keybindings

#+BEGIN_SRC emacs-lisp
(after! eww
  (defun t/eww-hook ()
    (map!
     :map evil-normal-state-local-map
     "q" 'quit-window
     "S-TAB" 'shr-previous-link
     "TAB" 'shr-next-link
     "R" 'eww-readable
     "M-p" 'backward-paragraph
     "M-n" 'forward-paragraph
     "s-l" 'eww
     "s" (t/spray-micro-state))))
(add-hook 'eww-mode-hook #'t/eww-hook)
#+END_SRC

*** Nrk.no

A custom function to fetch a clean view of the current news from nrk.no

#+BEGIN_SRC emacs-lisp :results silent
(defun t/clean-nrk-buffer ()
  (flush-lines "^$")
  ;; clean up lines beginning with dates, e.g. 20. sept...
  (beginning-of-buffer)
  (flush-lines "^[0-9][0-9]\.")

  ;; clean up lines beginning with -
  (beginning-of-buffer)
  (t/cleanup-buffer-whitespace-and-indent)
  (while (re-search-forward "*" nil t)
    ;; kill lines with dates, all these news are new
    (when (string-match-p "^* [0-9][0-9]\." (thing-at-point 'line))
      (kill-line) (forward-line) (join-line))
    ;; change * to -
    (replace-match "\n-")
    ;; highlight the line
    (add-text-properties (point-at-bol) (point-at-eol) '(face outline-4)))

  (beginning-of-buffer)

  ;; kill more lines with dates
  (while (re-search-forward "^[0-9][0-9]\." nil t)
    (when (string-match-p "^[0-9][0-9]\. [jfmasond]" (thing-at-point 'line))
      (beginning-of-line) (kill-line) (forward-line) (join-line)))

  ;; remove leading line
  (beginning-of-buffer)
  (kill-line)

  ;;(darkroom-mode)
  (read-only-mode)
  (funcall (t/micro-state (t/prefix-arg-universal?)
                          "n" (cmd! nil
                                        (evil-search "^-" t t)
                                        (evil-ex-nohighlight)
                                        (recenter nil))
                          "p" (cmd! nil
                                        (evil-search "^-" nil t)
                                        (evil-ex-nohighlight)
                                        (recenter nil))
                          "s" (t/spray-micro-state))))
#+END_SRC

Bind it to ~SPC o n~

#+begin_src emacs-lisp
(map!
 :leader
 (:prefix ("o" . "open")
  :desc "Show nrk.no" "n" (cmd! (t/eww-readable "https://www.nrk.no/nyheter/" 't/clean-nrk-buffer))))
#+end_src

** Languages
*** Clojure

Adapt cleverparens keys that clash with my M-[hjkl] bindings in [[file:~/.skhdrc][~/.skhdrc]]

#+begin_src emacs-lisp
(after! evil
  (map! :map evil-cleverparens-mode-map
        "C-M-h" 'evil-cp-beginning-of-defun
        "C-M-l" 'evil-cp-end-of-defun
        "C-M-k" 'evil-cp-drag-backward
        "C-M-j" 'evil-cp-drag-forward))
#+end_src

#+begin_src emacs-lisp
(after! clojure-mode
  (add-hook 'clojure-mode-hook 'evil-cleverparens-mode)
  (add-hook 'clojurescript-mode-hook 'evil-cleverparens-mode))
#+end_src

*** Emacs lisp

#+begin_src emacs-lisp
(after! evil
  (add-hook 'emacs-lisp-mode-hook #'evil-cleverparens-mode))
#+end_src

Show containing parens, when the cursor is inside theme

#+begin_src emacs-lisp
(define-advice show-paren-function (:around (fn) fix)
  "Highlight enclosing parens."
  (cond ((looking-at-p "\\s(") (funcall fn))
        (t (save-excursion
             (ignore-errors (backward-up-list))
             (funcall fn)))))
#+end_src

*** Terraform

Highlight terraform plans in ~terraform-mode~ based on their file name.

#+begin_src emacs-lisp
(add-to-list 'auto-mode-alist (cons (concat "^" (t/user-file "Downloads/") "tf_plan_.*") 'terraform-mode))
(add-hook! 'terraform-mode-hook
  (cmd!
   (when (s-contains-p "tf_plan_" buffer-file-name)
     (beginning-of-buffer)
     (evil-search "^───" t t)
     (call-interactively 'evil-scroll-line-to-top))
   (terraform-format-on-save-mode)
   (aggressive-indent-mode -1)))
#+end_src

** Server mode

Emacs server setup.

This name is used from skhdrc, ~/.emacs.d/emacsclient~, ~/.emacs.d/emacsclient~ and other places. The latter two are linked as ~e~ and ~em~ on the command line, to target the running emacs server instance, to quickly open a file or folder.

#+begin_src emacs-lisp
(setq server-name "torgemacs")
#+end_src

I also use this from Alfred, as a quick way of capturing from anywhere on os x.

#+begin_src sh :tangle no
/usr/local/bin/emacsclient -s torgemacs -e '(progn (select-frame-set-input-focus (selected-frame)) (org-capture))'
#+end_src

** Terminal
*** Vterm

This is paired with the bash function [[https://github.com/torgeir/dotfiles/blob/5a4909422f0822016a4e3745e919d7ca246872ec/source/functions#L280-L282][vterm_set_directory]] that updates the current working directory for emacs as the vterm path changes.

#+begin_src emacs-lisp
(after! vterm
  ;; https://github.com/akermu/emacs-libvterm#how-can-i-get-the-directory-tracking-in-a-more-understandable-way
  ;; see dotfiles/source/functions
  (add-to-list
   'vterm-eval-cmds
   '("update-pwd" (lambda (path) (setq default-directory path))))

  (add-to-list
   'vterm-eval-cmds
   '("magit-status" (lambda (path)
                      (let ((default-directory path))
                        (call-interactively' magit-status))))))
#+end_src

**** Keybindings

Some keybindings are so engrained I can't live without them.

#+begin_src emacs-lisp
(map! :map vterm-mode-map
      :m "C-a" 'vterm-send-C-a
      :m "M-<backspace>" 'vterm-send-C-w
      :i "M-<backspace>" 'vterm-send-C-w)
#+end_src

*** Terminal from everywhere with s-return
:PROPERTIES:
:ID:       607b5e84-af21-4da9-80a9-8a44c2d12f0b
:END:

Make super+enter create a vterm terminal window inside emacs

#+begin_src emacs-lisp
(map! :gn [s-return] #'+vterm/here)
#+end_src

Goes great with [[file:~/dotfiles/skhdrc::cmd - return \[][these lines from ~/.skhdrc]], that make super+enter create a terminal from other apps

*** TODO Port eshell stuff?

** VC
*** Ediff

Sometimes you need both changes.

#+begin_src emacs-lisp
(after! ediff
  (add-hook! 'ediff-keymap-setup-hook
            (cmd! (define-key ediff-mode-map "d" 't/ediff-use-both))))
#+end_src

*** Magit and Forge

Useful magit keybindings:

- ~S-SPC~ :: preview commit
- ~gj~ :: next and preview
- ~j~ :: next

#+begin_src emacs-lisp
(after! magit
  (setq magit-fetch-arguments '("--prune")
        magit-rebase-arguments '("--interactive")
        magit-log-arguments '("--graph" "--color" "--decorate" "-n256")
        git-commit-summary-max-length 72 ;; like github
        magit-display-buffer-function 'magit-display-buffer-fullcolumn-most-v1 ;; 'magit-display-buffer-traditional
        )

  (set-popup-rule! "^magit:" :ignore t)
  (set-popup-rule! "^magit-revision" :side 'right :size 0.5)
  ;;(set-popup-rule! "^magit-log" :side 'right :size 0.5)

  ;; equivalent using display-buffer-alist
  ;; (add-to-list 'display-buffer-alist '("magit-revision"
  ;;                                      (display-buffer-in-side-window)
  ;;                                      (window-width . 0.5)
  ;;                                      (side . right)
  ;;                                      (slot . -1)))
  )
#+end_src

Extend leader map with ~gn~ and ~gN~, for navigating hunks, the g] and g[ bindings never made sense to me. And ~gca~ for amending.

#+begin_src emacs-lisp
(map!
 :leader
 (:prefix-map
  ("g" . "git")
  (:when (featurep! :ui vc-gutter)
    :desc "Jump to next hunk"     "n" (cmd! (call-interactively 'git-gutter:next-hunk)
                                            (call-interactively 'evil-scroll-line-to-center))
    :desc "Jump to previous hunk" "N" (cmd! (call-interactively 'git-gutter:previous-hunk)
                                            (call-interactively 'evil-scroll-line-to-center)))
  (:when (featurep! :tools magit)
    :desc "Visit pulls"           "p" #'t/visit-git-link-pulls
    (:prefix ("c" . "create")
     :desc "Ammend"               "a"   #'magit-commit-amend))))
#+end_src

I have been trying to get used to magit in evil mode for a while now. But the magit-process-buffer keybinding is crazy on a norwegian keyboard, so this brings back the binding from the emacs mode magit.

#+begin_src emacs-lisp
(map!
 :map magit-status-mode-map
 :desc "Show process buffer" :n "$" #'magit-process-buffer)
#+end_src

** Applications
*** Artist

#+begin_src emacs-lisp
(defun t/artist-mode ()
  (interactive)
  (if (and (boundp 'artist-mode)
           artist-mode)
      (progn
        (artist-mode-off)
        (evil-normal-state))
    (progn
      (switch-to-buffer "*scratch*")
      (evil-insert-state)
      (artist-mode t))))

(after! artist
  (add-hook! 'artist-mode-hook
    (map!
     :map evil-insert-state-local-map "q" 'artist-mode-off
     :map evil-normal-state-local-map "q" 'artist-mode-off)))

(map!
 :leader
 (:prefix-map ("z" . "misc")
  (:prefix ("z" . "artist")
   (:when t
    :desc "Enable"      "t" 't/artist-mode
    :desc "Draw: pen"       "p" 'artist-select-op-pen-line
    :desc "Draw: line"      "l" 'artist-select-op-line
    :desc "Draw: rectangle" "r" 'artist-select-op-rectangle
    :desc "Draw: circle"    "c" 'artist-select-op-circle
    :desc "Draw: ellips"    "e" 'artist-select-op-ellipse
    :desc "Draw: square"    "s" 'artist-select-op-square))))
#+end_src

*** Elfeed RSS

#+begin_src emacs-lisp
(after! elfeed
  (setq rmh-elfeed-org-files '("~/Dropbox/org/feeds.org")
        elfeed-search-filter "@2-week-ago +unread -news -tech")

  (map!
   (:after elfeed
    :map elfeed-search-mode-map
    ;; switcharoo
    :n "gR" #'elfeed-search-update--force
    :n "gr" #'elfeed-search-fetch))

  (add-hook 'elfeed-show-mode-hook #'t/elfeed-show-mode-hook)
  (defun t/elfeed-show-mode-hook ()
    (interactive)
    (olivetti-mode)
    (visual-line-mode 0)
    (visual-line-mode nil)
    (let ((map (make-sparse-keymap)))
      (bind-key "n" (lambda ()
                      (interactive)
                      (condition-case nil
                          (scroll-up-command)
                        (error (elfeed-show-next)))) map)
      (bind-key "p" (lambda ()
                      (interactive)
                      (condition-case nil
                          (scroll-down-command)
                        (error (elfeed-show-prev)))) map)
      (bind-key "s" (cmd!
                     (let ((shr-inhibit-images t)) (elfeed-show-refresh))
                     (funcall (t/spray-micro-state))) map)
      (set-temporary-overlay-map map t (lambda () (equal major-mode 'elfeed-show-mode))))))
#+end_src

*** Calendar

Weeks on start on monday in Norway, and weeks have numbers.

#+begin_src emacs-lisp
(after! calendar
  (setq calendar-week-start-day 1
        calendar-intermonth-text
        '(propertize (format "%2d" (car
                                    (calendar-iso-from-absolute
                                     (calendar-absolute-from-gregorian
                                      (list month day year)))))
                     'font-lock-face 'calendar-iso-week-face))
  (copy-face font-lock-constant-face 'calendar-iso-week-face)
  (copy-face 'default 'calendar-iso-week-header-face))
#+end_src

Evil like navigation.

#+begin_src emacs-lisp
(after! calendar
  (add-hook! 'calendar-mode-hook
    (map!
     :map calendar-mode-map
     :m "H"   #'calendar-scroll-left
     :m "L"   #'calendar-scroll-right)))
#+end_src

*** Re-builder

#+begin_src emacs-lisp
(after! re-builder
  (setq reb-re-syntax 'rx)
  (defvar t-regex-mode nil "reb-mode on or not"))

(defun t/toggle-regex-mode ()
  (interactive)
  (if t-regex-mode (reb-quit) (re-builder))
  (setq t-regex-mode (not t-regex-mode)))
#+end_src

*** Twitter

#+begin_src emacs-lisp
(after! twittering-mode
  (setq twittering-initial-timeline-spec-string '(":mentions" ":home")
        twittering-request-confirmation-on-posting t
        twittering-use-master-password t))
#+end_src

** Site lisp

Useful elisp I committed, or decided to work on.

#+begin_src emacs-lisp
(after! org
  (use-package! ox-gfm
    :commands org-export-dispatch
    :load-path "site-lisp/ox-gfm/"))
#+end_src

#+begin_src emacs-lisp
;; TODO why is ~/.doom.d, tho
(use-package! consult-async
  :commands consult-web-search
  :load-path "~/.doom.d/site-lisp/consult-async/")
#+end_src

TODO idle highlight in visible buffers

#+begin_src emacs-lisp
;; don't use this for large files, e.g. like 15MB, it really brings emacs to a stall
(use-package! nxml-eldoc
  :load-path "site-lisp/nxml-eldoc/"
  :commands turn-on-nxml-eldoc)
#+end_src

#+begin_src emacs-lisp
(use-package! json-path-eldoc
  :commands turn-on-json-path-eldoc
  :init (add-hook! 'json-mode-hook 'turn-on-json-path-eldoc)
  :load-path "site-lisp/json-path-eldoc/")
#+end_src

#+begin_src emacs-lisp
(comment
 (message "result: %s"
          (consult-t-async (lambda (action fn)
                             (t/async-shell-command
                              "file listing"
                              (concat "ls -l " action)
                              (lambda (p code res)
                                (funcall fn res)))))))
#+end_src

** Stuff to test
*** Run in every file opened

#+begin_src emacs-lisp
(add-hook 'find-file-hook 't/in-every-file)
(defun t/in-every-file ()
  ;;(when (string= (file-name-extension buffer-file-name) "ts") (typescript-mode))
  )
#+end_src

*** Skeleton mode instead of yasnippet?

https://www.emacswiki.org/emacs/SkeletonMode

#+begin_src elisp
(comment
 (define-skeleton skel-defun
   "Insert a defun template."
   "Name: "
   "(defun " str " (" @ - ")" \n
   "(" @ _ ")" \n)

 (defvar *skeleton-markers* nil
   "Markers for locations saved in skeleton-positions")

 (add-hook 'skeleton-end-hook 'skeleton-make-markers)

 (defun skeleton-make-markers ()
   (while *skeleton-markers*
     (set-marker (pop *skeleton-markers*) nil))
   (setq *skeleton-markers*
         (mapcar 'copy-marker (reverse skeleton-positions))))

 (defun skeleton-next-position (&optional reverse)
   "Jump to next position in skeleton.
         REVERSE - Jump to previous position in skeleton"
   (interactive "P")
   (let* ((positions (mapcar 'marker-position *skeleton-markers*))
          (positions (if reverse (reverse positions) positions))
          (comp (if reverse '> '<))
          pos)
     (when positions
       (if (catch 'break
             (while (setq pos (pop positions))
               (when (funcall comp (point) pos)
                 (throw 'break t))))
           (goto-char pos)
         (goto-char (marker-position
                     (car *skeleton-markers*))))))))
#+end_src

*** Sticky buffer mode

Useful e.g. to make dired act like a directory tree sidebar

#+begin_src emacs-lisp :results silent
(define-minor-mode sticky-buffer-mode
  "Make the current window always display this buffer."
  nil " sticky" nil
  (set-window-dedicated-p (selected-window) sticky-buffer-mode)
  (setq window-size-fixed (if sticky-buffer-mode 'width nil)))
#+end_src

*** gh run watch

#+begin_src emacs-lisp :results silent
(defun t/gha ()
  (interactive)
  (+vterm/toggle nil)
  (term-send-raw-string "gh run watch\C-m"))
#+end_src

*** xref jump to selection

#+begin_src emacs-lisp
(comment

 (progn

   (require 'xref)
   (let ((l (xref-location-marker
             (xref-make-file-location
              (t/user-emacs-file "test-files/index.js")
              27
              11))))
     (xref--show-pos-in-buf l (marker-buffer l))))
 )
#+end_src

** Fun stuff

*** Embark org ToC

Type ~mgg~ to run =consult-org-heading=, then ~C-c C-;~ to =embark-export=.

*** Macro numbered list

Type ~qq~ to record a macro to ~q~. Move to where you want the number and press ~C-x C-k C-i~. Move to the next line start to make the macro repeatble. Type ~q~. Undo. Select the list and hit ~@q~.

- one
- two
- three

* Someday
** TODO Org pomodoro? - Doom Emacs v21.08 documentation :emacs:
[2022-10-02 Sun 23:34]
https://docs.doomemacs.org/latest/#/manual/intro/why-use-doom

** TODO :editor format +onsave - Doom Emacs v21.08 documentation :emacs:
[2022-10-02 Sun 23:27]
https://docs.doomemacs.org/latest/modules/editor/format/

** TODO Show workspace in modeline

(+workspace--tabline)

** TODO Doom modeline additions ws

** TODO avy farge som i branchnacn
** TODO dired som bare flytter til venstre og blir dedicated

** Prot's Orderless

A tuned version of [[https://protesilaos.com/codelog/2021-01-06-emacs-default-completion/][Prot's]] and [[https://kristofferbalintona.me/posts/202202211546/][Kristoffer Balintona's]] vertico, maginalia and orderless setup

Some examples and explanations

- m-x: name= ^[m] :: contains chars of name in word in order AND starts with regex m
- m-x: Buffer= e nm= :: contains chars of Buffer in word in order AND contains e AND contains chars of nm in word in order (e.g. like in u<nm>ark)
- SPC s p: #defun#j gjp, ha, :: rg search for defun, in-emacs matching for long words that have leading inner words starting with g j and p in order, and have leading inner words starting with h and a

#+begin_src emacs-lisp
(after! orderless

  (setq marginalia-max-relative-age 0)

  (progn

    (setq orderless-matching-styles
          '(orderless-initialism
            orderless-literal
            orderless-regexp
            orderless-flex))

    (setq orderless-style-dispatchers
          '(prot-orderless-literal-dispatcher
            prot-orderless-initialism-dispatcher
            prot-orderless-flex-dispatcher
            ))

    (defun prot-orderless-literal-dispatcher (pattern _index _total)
      "Literal style dispatcher using the equals sign as a suffix.
E.g.
Buffer= e nm=
Buffer-menu-unmark
^^^^^^       ^^
Buffer-menu-unmark-all
^^^^^^       ^^
Buffer-menu-backup-unmark
^^^^^^              ^^
Buffer-menu-unmark-all-buffers
^^^^^^       ^^
"
      (when (string-suffix-p "=" pattern)
        `(orderless-literal . ,(substring pattern 0 -1))))

    ;;;###autoload
    (defun prot-orderless-initialism-dispatcher (pattern _index _total)
      "Matches leading on words in order
E.g.
#defun#j gjp, ha,
(defun t/js2-get-json-path (&optional hardcoded-array-index))
 ^^^^^       ^   ^    ^               ^         ^

#defun#j gjp, hi,
Would not match the above as no leading words start h then another word starting with i
"
      (when (string-suffix-p "," pattern)
        `(orderless-strict-initialism . ,(substring pattern 0 -1))))

    ;;;###autoload
    (defun prot-orderless-flex-dispatcher (pattern _index _total)
      "Matches using any group in any order."
      (when (string-suffix-p "." pattern)
        `(orderless-flex . ,(substring pattern 0 -1))))

    (defun orderless-strict-initialism (component)
      "Match a COMPONENT as a strict initialism, optionally ANCHORED.
The characters in COMPONENT must occur in the candidate in that
order at the beginning of subsequent words comprised of letters.
Only non-letters can be in between the words that start with the
initials.

If ANCHORED is `start' require that the first initial appear in
the first word of the candidate.  If ANCHORED is `both' require
that the first and last initials appear in the first and last
words of the candidate, respectively."
      (orderless--separated-by
          '(seq (zero-or-more alpha) word-end (zero-or-more (not alpha)))
        (cl-loop for char across component collect `(seq word-start ,char))))))
#+end_src
