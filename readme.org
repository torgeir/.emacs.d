#+STARTUP: content
#+PROPERTY: header-args:emacs-lisp :lexical t
* .emacs.d

** Install

Install it by cloning the repo.

#+BEGIN_SRC sh :results silent
cd && git clone git@github.com:torgeir/.emacs.d.git
#+END_SRC

*** Os setup
**** Shortcuts

#+BEGIN_SRC sh :results silent
ln -s ~/.emacs.d/emacsclient ~/bin/e
ln -s ~/.emacs.d/emacsclient-terminal ~/bin/em
#+END_SRC

**** Deps

#+BEGIN_SRC sh :results silent
npm -g install eslint babel-eslint jsonlint eslint-plugin-react typescript-language-server typescript jscodeshift browser-sync
#+END_SRC

**** OS X

#+BEGIN_SRC sh :results silent
brew tap d12frosted/emacs-plus
brew install emacs-plus --HEAD --with-natural-title-bar --without-spacemacs-icon
#+END_SRC

**** Ubuntu

#+BEGIN_SRC sh :results silent
sudo add-apt-repository -y ppa:ubuntu-elisp
sudo apt update
sudo apt install emacs-snapshot
sudo apt install fonts-inconsolata
sudo fc-cache -fv
#+END_SRC

** Bootstrap

*** User

#+BEGIN_SRC emacs-lisp :results silent
(defconst t-leader "SPC")
(defconst t-emacs-leader "C-")
(defconst t-font-size 17)
(defconst lat-trh 63.427)
(defconst lon-trh 10.391)
(defconst loc-trh "Trondheim, Norway")

#+END_SRC

*** Operating system

#+BEGIN_SRC emacs-lisp :results silent
(defconst is-mac (equal system-type 'darwin))
(defconst is-cygwin (equal system-type 'cygwin))
(defconst is-linux (equal system-type 'gnu/linux))
(defconst is-win (equal system-type 'windows-nt))
(defconst is-ms (or is-cygwin is-win))
(defconst has-gui (display-graphic-p))
#+END_SRC

*** Dynamically bound

#+BEGIN_SRC emacs-lisp :results silent
(defvar *t-indent* 2)
(defvar *t-indent-xml* 4)
(defvar *t-debug-init* nil "Debug/time startup")
(when *t-debug-init* (setq debug-on-error nil))

#+END_SRC

*** User folders

#+BEGIN_SRC emacs-lisp :results silent
(defconst user-emacs-directory "~/.emacs.d/")
(defun t/user-emacs-file (path) (concat user-emacs-directory path))
(defun t/user-file (path)
  (concat (if is-mac "/Users/"
            (if is-linux "/home/" "c:/Users/"))
          (if is-win "torgth" (replace-regexp-in-string "\\." "" (getenv "USER")))
          "/"
          path))
(defconst t-user-dropbox-folder (if (or is-mac is-linux)
                                    (t/user-file "Dropbox")
                                  "c:/Users/torgth/Dropbox \(Personlig\)"))
(defun t/user-dropbox-folder (path) (concat t-user-dropbox-folder "/" path))
#+END_SRC

*** Load path

Add setup and snippets to the load-path.

#+BEGIN_SRC emacs-lisp :results silent
(defconst t-dir-setup (t/user-emacs-file "setup"))
(defconst t-dir-snippets (t/user-emacs-file "snippets"))

(add-to-list 'load-path t-dir-setup)
(add-to-list 'load-path (t/user-emacs-file "setup/langs"))
(let ((dir-site-lisp (t/user-emacs-file "site-lisp")))
  (add-to-list 'load-path dir-site-lisp)
  ;; add folders inside site-lisp as well
  (dolist (project (directory-files dir-site-lisp t "\\w+"))
    (when (file-directory-p project)
      (add-to-list 'load-path project))))
#+END_SRC

** Timing functions

Functions to record time spent loading the emacs config. Benchmarks can be
provided when initialization is complete by setting ~*t-debug-init*~ to ~t~.

#+BEGIN_SRC emacs-lisp :results silent
(defun t/timing-start ()
  (interactive)
  (when *t-debug-init*
    (message "t: timing init")
    (require 't-debug)

    ;; benchmarks
    (use-package benchmark-init :config (benchmark-init/activate))))

(defun t/timing-end ()
  (interactive)
  (when *t-debug-init*
    (message "t: timing init complete")
    (benchmark-init/show-durations-tabulated)
    (benchmark-init/show-durations-tree)))
#+END_SRC

** Before

Start the initialization timer.

#+BEGIN_SRC emacs-lisp :results silent
(t/timing-start)
#+END_SRC

Hook for private stuff before the rest. Useful e.g. for gcal tokens etc.

#+BEGIN_SRC emacs-lisp :results silent
(load (t/user-emacs-file "t-before.el") t)
#+END_SRC

** Autoloads

Autoloads, that auto reload when you save them. A myriad of useful functions
with autoload cookies are in ~t-defuns.el~.

#+BEGIN_SRC emacs-lisp :results silent
(defconst t-file-autoloads (t/user-emacs-file "setup/autoloads.el"))

(defun t/reload-autoloads ()
  "Regenerate and reload autoloads.el."
  (interactive)
  (let ((generated-autoload-file t-file-autoloads))
    (update-directory-autoloads (concat t-dir-setup "/"))
    (when (called-interactively-p 'interactive) (load t-file-autoloads t t))))

(unless (require 'autoloads t-file-autoloads t)
  (t/reload-autoloads)
  (unless (require 'autoloads t-file-autoloads t) (error "autoloads.el not generated!")))

#+END_SRC

** Implicits

#+BEGIN_SRC emacs-lisp :results silent
(require 'bind-key)
(require 'cl) ;; TODO s/lexical-let/let ?
(use-package diminish)
(use-package dash) ; list helpers
(use-package dash-functional) ; fun list helpers
(use-package s) ; string helpers
(use-package f) ; file helpers
#+END_SRC

** Customize

Customizations go in ~custom.el~.

#+BEGIN_SRC emacs-lisp :results silent
(setq custom-file (locate-user-emacs-file "custom.el"))
(load custom-file)
#+END_SRC

** Macros

A couple of macros, probably inspired by doom-emacs trickery.

#+BEGIN_SRC emacs-lisp :results silent
(require 'subr-x)
#+END_SRC

So simple, yet so useful. Ignores a complete elisp code block, no matter what
the contents, like the one clojure <3

#+BEGIN_SRC emacs-lisp :results silent
(defmacro comment (&rest ignore)
  "Ignore stuff, return `nil'."
  nil)
#+END_SRC

Shortcut for interactive lambdas, you can omit the arg list as well.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/lambda (&optional args &rest body)
  (declare (indent 1))
  (if body
      `(lambda ,args (interactive) ,@body)
    `(lambda (&optional &rest ignore) (interactive) ,args)))

(comment
 (t/lambda)
 (t/lambda 1)
 (t/lambda (one two) 1))
#+END_SRC

Shorthand for running code after a file name has been loaded.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/after (file-name &rest body)
  (declare (indent 1))
  (if (locate-library (symbol-name file-name))
      `(with-eval-after-load ',file-name ,@body)
    (message "t/after: for %s is not a filename in load-path?" file-name)))

#+END_SRC

Runs body of code only for buffers with the given extension ~ext~.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/when-ext (ext &rest body)
  "Run `body' when buffer's file has extension `ext'."
  (declare (indent 1))
  `(let ((ext-re (concat "\\." ,ext "$")))
     (when (and (buffer-file-name)
                (string-match ext-re (buffer-file-name)))
       ,@body)))

#+END_SRC

Make parameter a list, if it isn't already.

#+BEGIN_SRC emacs-lisp :results silent
(defun t/ensure-list (i-or-is)
  "Ensure `i-or-is' is a list."
  (if (and (listp i-or-is)
           (not (functionp i-or-is)) ; lambda
           )
      i-or-is
    (list i-or-is)))

#+END_SRC

A more forgiving version of add-hook.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/add-hook (hook-or-hooks fn-or-fns &optional append local)
  "Add one or more hook fns."
  (comment (dolist (hook (t/ensure-list (eval hook-or-hooks)))
             (unless (or (boundp hook) (listp hook))
               (message "%s is not a hook" hook))))
  `(let ((hooks (t/ensure-list ,hook-or-hooks))
         (fns (t/ensure-list ,fn-or-fns)))
     (dolist (hook hooks)
       (dolist (fn fns)
         (add-hook hook fn ,append ,local)))))

#+END_SRC

A more forgiving version of remove-hook.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/remove-hook (hook-or-hooks fn-or-fns)
  "Remove one or more hook fns"
  `(let ((hooks (t/ensure-list ,hook-or-hooks))
         (fns (t/ensure-list ,fn-or-fns)))
     (dolist (hook hooks)
       (dolist (fn fns)
         (remove-hook hook fn)))))
#+END_SRC

A combined setq and a hook.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/add-hook-setq (hook-or-hooks var_ val_ &rest vars_)
  "A `setq' run in hooks."
  `(t/add-hook ,hook-or-hooks
               (lambda nil
                 (let ((var (quote ,var_))
                       (val (quote ,val_))
                       (vars (quote ,vars_))
                       (bindings '(setq)))
                   (while var
                     (setq bindings (cons val (cons var bindings))
                           var (and vars (pop vars))
                           val (and vars (pop vars))))
                   (eval (nreverse (copy-list bindings)))))))

#+END_SRC

This is probably lefovers from before discovering ~bind-key~ already does this -
much better.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/bind-in (maps_ key_ fn_ &rest bindings)
  "Bind keys in maps."
  (declare (indent 1))
  `(let ((maps (t/ensure-list ,maps_))
         (key (quote ,key_))
         (fn (quote ,fn_))
         (bs (quote ,bindings)))
     (while key
       (dolist (map maps)
         (eval `(bind-key ,key ,fn ,map)))
       (setq key (and bs (pop bs))
             fn (and bs (pop bs))))))

#+END_SRC

A combined named function definition and a hook.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/add-hook-defun (hook-or-hooks fn &rest body)
  "Create a defun `fn' with `body' in `hook-or-hooks'."
  `(progn
     (defun ,fn () (interactive) ,@body)
     (t/add-hook ,hook-or-hooks (quote ,fn))))

#+END_SRC

A reloadable timer that runs a ~fn~ on a given interval.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/idle-timer (name fn every-minute)
  "Reloadable variant of run-with-idle-timer."
  `(progn
     (when (and (boundp ',name) ,name) (cancel-timer ,name))
     (setq ,name (run-with-idle-timer (* ,every-minute 60) t ,fn))))

#+END_SRC

Call a function that might not be loaded.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/safe-call (fn)
  "Expands to call `fn' only if it is bound to a function."
  `(when (fboundp (quote ,fn))
     (funcall (quote ,fn))))

#+END_SRC

No longer in use. Useful for tracking what loads, and making the init and config
process of packages reproducable.

#+BEGIN_SRC emacs-lisp :results silent
(comment

  (defvar t-use-package-pkgs nil
    "List of all packages inited by t/use-package that will be used
for setting up vars and config after load")
  (setq t-use-package-pkgs nil)

  (defmacro t/use-package (package &optional key value &rest bindings)
    (declare (indent 1))
    (let* ((entries '())
           (init-name (intern (format "t/init-%s" package)))
           (vars-name (intern (format "t/vars-%s" package)))
           (config-name (intern (format "t/config-%s" package))))

      (while key
        (push value entries)
        (push key entries)
        (setq key (pop bindings)
              value (pop bindings)))

      (let* ((init-body (plist-get entries :init))
             (config-body (plist-get entries :config))
             (body '()))

        ;; make :init and :config call defuns instead
        (setq entries (plist-put entries :init `(,vars-name)))
        (setq entries (plist-put entries :config `(,config-name)))

        ;; pass through some other use-package keys
        (let ((ks (list :if :init :config :mode :bind :ensure :diminish :after
                        :hook :commands :defer :load-path :pin :evil-state)))
          (dolist (k ks)
            (when (plist-member entries k)
              (let ((v (plist-get entries k)))
                (setq body (plist-put body k v))))))

        (add-to-list 't-use-package-pkgs init-name t)
        (setq t-use-package-pkgs (delete-dups t-use-package-pkgs))

        `(progn
           (defun ,vars-name ()
             (interactive)
             (when *t-debug-init*
               (message "t/use-package vars: %s" (symbol-name ',vars-name)))
             ,init-body)
           (defun ,config-name ()
             (interactive)
             (when *t-debug-init*
               (message "t/use-package config: %s" (symbol-name ',config-name)))
             ,config-body)
           (defun ,init-name ()
             (interactive)
             (when *t-debug-init*
               (message "t/use-package init: %s" (symbol-name ',init-name)))
             (use-package ,package ,@body)))))))

;; tests

(comment
 (plist-member '(:one nil :two 2) :one)
 (plist-member '(:one nil :two 2) :ensure)

 (pp (macroexpand-1 '(t/use-package wow
                       :ensure nil
                       :straight nil
                       :commands (winner-mode)
                       :bind (:map winner-mode-map ("C-c <left>" . winner-undo)))))
 )

(comment

 (t/use-package winner
   :bind (:map winner-mode-map ("C-c <left>" . winner-undo))
   :init (message "init")
   :config (message "config"))

 t-use-package-pkgs

 (symbol-function 't/vars-winner)
 (symbol-function 't/config-winner)
 (symbol-function 't/init-winner))

(comment
 (delete-dups '(1 2 3 1 2 3)))

(comment
 (t/use-package whaat
   :config
   (progn
     (message "config what one")
     (message "config what two"))
   :bind (+ 1 2))

 (symbol-function 't/vars-whaat)
 (symbol-function 't/config-whaat)
 (symbol-function 't/init-whaat))

(comment
 (symbol-function 't/config-which-key))

#+END_SRC

Create smart parens wrapping functions.

#+BEGIN_SRC emacs-lisp :results silent
(defmacro t/def-pairs (pairs)
  "Create smartparens wrapping function, e.g. t/wrap-with-paren"
  `(progn
     ,@(loop for (key . val) in pairs
             collect
             `(defun ,(read (concat
                             "t/wrap-with-"
                             (prin1-to-string key)
                             "s"))
                  (&optional arg)
                (interactive "p")
                (sp-wrap-with-pair ,val)))))
#+END_SRC

** Os specific
*** Mac

#+BEGIN_SRC emacs-lisp :results silent
(when is-mac

  (use-package exec-path-from-shell :config (exec-path-from-shell-initialize))

  ;; mouse
  (setq ns-use-mwheel-momentum t
        ns-use-mwheel-acceleration t

        ;; for some reason makes ci{[ work on os x
        ;; with evil-surround with a norwegian keyboard..
        mac-right-option-modifier nil

        ;; bind fn to H-
        ns-function-modifier 'hyper

        shell-file-name "/bin/sh" ; cause zsh makes projectile unable to find the git repo

        trash-directory "~/.Trash/emacs")

  ;; dark title bar
  (add-to-list 'default-frame-alist '(ns-transparent-titlebar . t))
  (add-to-list 'default-frame-alist '(ns-appearance . dark))

  (t/bind-in 'key-translation-map
    ;; translate norwegian os x keybindings
    "M-7" "|"
    "M-/" "\\"
    "M-8" "["
    "M-9" "]"
    "M-(" "{"
    "M-)" "}")

  (t/bind-in 'global-map
    ;; s-p print dialog kills emacs, so disable it..
    "s-p" nil
    ;; don't pop up font menu, makes new tab work in iterm2
    "s-t" nil)

  ;; make this run also after connecting with emacsclient
  ;; https://groups.google.com/forum/#!topic/gnu.emacs.help/ZGu2MNkJGrI
  (defadvice terminal-init-xterm (after map-S-up-escape-sequence activate)
    (t/bind-in 'input-decode-map
      ;; fix terminal shortcomings, remap them in iterm2, and bring tem back here
      ;; unused keys are e.g. above f17 which is ^[[15;2~ in emacs that is \e[15;2\~
      ;; http://aperiodic.net/phil/archives/Geekery/term-function-keys.html
      "\e[15;2\~" "C-SPC"
      "\e[17;2\~" "C-M-SPC"
      "\e[18;2\~" "C-."
      "\e[19;2\~" "C-,"
      ;; c-æ on a norwegian mac keyboard IS the ansi escape character ^[
      ;; for debugging run: (read-key-sequence "?")
      "\e[20;2\~" "C-æ"
      ;; c-ø on a norwegian mac keyboard is ^\
      "C-\\" "C-ø"
      ;; c-å on a norwegian mac keyboard is ^]
      "C-]" "C-å"
      ;; skip \e21;2~, its f10? what
      "\e[22;2\~" "C-'")))
#+END_SRC

*** Linux

#+BEGIN_SRC emacs-lisp :results silent
(when is-linux
  (setq t-font-size 14
        shell-file-name "/bin/zsh")

  (use-package exec-path-from-shell :config (exec-path-from-shell-initialize))

  (t/bind-in 'key-translation-map
    ;; translate norwegian os x keybindings
    "M-7" "|"
    "M-/" "\\"
    "M-8" "["
    "M-9" "]"
    "M-(" "{"
    "M-)" "}")

  ;; os x window movement
  (t/bind-in 'global-map
    "s-k" 'previous-buffer
    "s-j" 'next-buffer
    "s->" 'next-multiframe-window
    "s-<" 'previous-multiframe-window
    "s-<left>" 't/smart-beginning-of-line
    "s-<right>" 'end-of-line
    "M-s-<up>" 'windmove-up
    "M-s-<right>" 'windmove-right
    "M-s-<down>" 'windmove-down
    "M-s-<left>" 'windmove-left
    "s-d" 't/split-window-right-and-move-there-dammit
    "s-D" 't/split-window-below-and-move-there-dammit

    "s-c" 'evil-yank
    "s-v" 'evil-paste-after
    "s-z" 'undo-tree-undo
    "s-s" 'save-buffer
    "s-a" 'mark-whole-buffer
    "s-w" 'delete-frame
    "s-n" 'make-frame

    ;; s-w quits like C-x C-w
    "s-w" #'t/delete-frame-or-hide-last-remaining-frame
    "s-q" 'restart-emacs

    ;; buffer font size adjustment
    "s-?" (t/lambda (text-scale-increase 1))
    "s-_" (t/lambda (text-scale-decrease 1))
    "s-=" (t/lambda (text-scale-set 0))

    ;; global font size adjustment
    "s-+" 't/increase-font-size
    "s--" 't/decrease-font-size
    "s-0" 't/reset-font-size))
#+END_SRC

*** Cygwin

It was worth a shoot.. WSL2 is probably a better choice these days.

#+BEGIN_SRC emacs-lisp :results silent
(when is-ms
  (setq t-font-size 12
        shell-file-name "C:/Program Files/Git/bin/bash.exe")

  (t/bind-in 'global-map
    "C-+" 't/increase-font-size
    "C--" 't/decrease-font-size
    "C-0" 't/reset-font-size)

  (defun make-auto-save-file-name ()
    "torgeir: copied this from ftp://ftp.gnu.org/old-gnu/emacs/windows/docs/faq8.html. Fixes an issue when in gui emacs on windows it cant save backup files.

  Return file name to use for auto-saves of current buffer.
Does not consider `auto-save-visited-file-name' as that variable is checked
before calling this function.  This version stores all auto-save files in the
same local directory. This is to avoid trying to save files over a dial-up
connection (which may not be active).  See also `auto-save-file-name-p'."
    (if buffer-file-name
        (if (and (eq system-type 'ms-dos)
                 (not (msdos-long-file-names)))
            (let ((fn (file-name-nondirectory buffer-file-name)))
              (string-match "\\`\\([^.]+\\)\\(\\.\\(..?\\)?.?\\|\\)\\'" fn)
              (concat (expand-file-name "~/save/")
                      "#" (match-string 1 fn)
                      "." (match-string 3 fn) "#"))
          (concat (expand-file-name "~/.save/")
                  "#"
                  (file-name-nondirectory buffer-file-name)
                  "#"
                  (make-temp-name "")))

      ;; Deal with buffers that don't have any associated files.  (Mail
      ;; mode tends to create a good number of these.)

      (let ((buf-name (buffer-name))
            (limit 0))

        ;; Use technique from Sebastian Kremer's auto-save
        ;; package to turn slashes into \\!.  This ensures that
        ;; the auto-save buffer name is unique.

        (while (string-match "[/\\*?':]" buf-name limit)
          (message "%s" buf-name)
          (setq buf-name (concat (substring buf-name 0 (match-beginning 0))
                                 (if (string= (substring buf-name
                                                         (match-beginning 0)
                                                         (match-end 0))
                                              "/")
                                     "\\!"
                                   (if (string= (substring buf-name
                                                           (match-beginning 0)
                                                           (match-end 0))
                                                "\\\\")
                                       "\\\\" "__"))
                                 (substring buf-name (match-end 0))))
          (setq limit (1+ (match-end 0))))

        (expand-file-name
         (format "~/.save/#%s#%s#" buf-name (make-temp-name ""))))))
  )
#+END_SRC

** Sanity

Utf-8 everywhere.

#+BEGIN_SRC emacs-lisp :results silent
;; utf-8 ffs
(setq locale-coding-system 'utf-8
      default-buffer-file-coding-system 'utf-8)

(add-to-list 'file-coding-system-alist '("\\.org" . utf-8))
(prefer-coding-system 'utf-8)
#+END_SRC

A modern icon set.

#+BEGIN_SRC emacs-lisp :results silent
(use-package all-the-icons)
#+END_SRC

Rid the insanity. Well, try at least.

#+BEGIN_SRC emacs-lisp :results silent
(use-package better-defaults)
#+END_SRC

Fix the rest..

#+BEGIN_SRC emacs-lisp :results silent
(setq-default
 word-wrap t ; wrap for continued lines
 delete-by-moving-to-trash t ; delete files for realz
 mode-require-final-newline nil ; don't require final newline
 require-final-newline nil ; don't require final newline
 redisplay-dont-pause t ; update screen immediately
 x-underline-at-descent-line t ; draw underline lower
 help-window-select 't ; focus help buffers
 visible-bell t ; visible bell
 ring-bell-function 'ignore ; no bell
 compilation-scroll-output 'first-error ; scroll compilation to first error
 window-combination-resize t ; resize proportionally
 initial-major-mode 'emacs-lisp-mode ; load *scratch* in text-mode
 initial-scratch-message nil ; clear *scratch* buffer
 echo-keystrokes 0.001 ; show keystrokes
 save-interprogram-paste-before-kill t ; clipboard contents into kill-ring before replace
 font-lock-maximum-decoration t ; gaudiest possible look
 truncate-partial-width-windows nil ; don't truncate lines
 indicate-empty-lines nil ; don't show empty lines after buffer
 indicate-buffer-boundaries nil ; don't show buffer start/end
 fringes-outside-margins t       ; switches order of fringe and margin
 frame-title-format "%b (%f)"; full path in titlebar
 inhibit-startup-message t ; no splash
 sentence-end-double-space nil ; one space between sentences
 ad-redefinition-action 'accept ; silence useless warnings, e.g. ad-handle-definition: `find-tag-noselect' got redefined
 fill-column 80 ; chars per line
 gc-cons-threshold (* 8 1024 1024) ; more memory
 indent-tabs-mode nil ; don't use tabs
 tab-width *t-indent* ; two spaces
 cursor-in-non-selected-windows nil ; no cursor in other open windows
 eval-expression-print-length nil ; no length limit when printing sexps in message buffer
 eval-expression-print-level nil ; no level limit when printing sexps in message buffer
 frame-resize-pixelwise t)
#+END_SRC

Open large files removing heavy modes.

#+BEGIN_SRC emacs-lisp :results silent
(global-so-long-mode 1)

#+END_SRC

Y or n will do.

#+BEGIN_SRC emacs-lisp :results silent
(defalias 'yes-or-no-p 'y-or-n-p)

#+END_SRC

Don't blink cursor.

#+BEGIN_SRC emacs-lisp :results silent
(blink-cursor-mode -1)
#+END_SRC

Remove menus.

#+BEGIN_SRC emacs-lisp :results silent
(when window-system
  (tooltip-mode -1)
  (tool-bar-mode -1)
  (scroll-bar-mode -1)
  (menu-bar-mode -1))

#+END_SRC

Show active region.

#+BEGIN_SRC emacs-lisp :results silent
(transient-mark-mode 0)
(make-variable-buffer-local 'transient-mark-mode)
(put 'transient-mark-mode 'permanent-local t)
(setq-default transient-mark-mode t)
#+END_SRC

Show matching parens.

#+BEGIN_SRC emacs-lisp :results silent
(show-paren-mode t)
(setq show-paren-delay 0)
#+END_SRC

Remove selected text when typing.

#+BEGIN_SRC emacs-lisp :results silent
(delete-selection-mode t)

#+END_SRC

Above what sizes can the window split?

#+BEGIN_SRC emacs-lisp :results silent
(setq split-height-threshold 0
      split-width-threshold 0
      split-window-preferred-function #'t/split-window-sensibly)

#+END_SRC

Remember file positions, and layout. Super useful, e.g. for dired.

#+BEGIN_SRC emacs-lisp :results silent
(save-place-mode 1)
#+END_SRC

Don't save desktop automatically, for now.

#+BEGIN_SRC emacs-lisp :results silent
;; (desktop-save-mode 1)
;; (setq desktop-save 't)
#+END_SRC

Eldoc everywhere.

#+BEGIN_SRC emacs-lisp :results silent
(global-eldoc-mode)

#+END_SRC

Colocate temporary files.

#+BEGIN_SRC emacs-lisp :results silent
(setq backup-directory-alist `((".*" . ,(locate-user-emacs-file ".backups/")))
      auto-save-file-name-transforms `((".*" ,(locate-user-emacs-file ".auto-save-list/") t))
      auto-save-list-file-prefix (locate-user-emacs-file ".auto-save-list/")
      recentf-save-file (locate-user-emacs-file ".recentf")
      save-place-file (locate-user-emacs-file ".places")
      save-place-forget-unreadable-files nil
      create-lockfiles nil
      ido-save-directory-list-file (locate-user-emacs-file ".ido.last"))
#+END_SRC

Mouse support, with scroll.

#+BEGIN_SRC emacs-lisp :results silent
(xterm-mouse-mode t)
(defun trackp-mouse (e))
(setq mouse-sel-mode t)

(when (require 'mwheel nil 'noerror)
  (global-set-key [wheel-down] (t/lambda (scroll-down 2)))
  (global-set-key [wheel-up] (t/lambda (scroll-up 2)))
  (global-set-key [mouse-4] (t/lambda (scroll-down 2)))
  (global-set-key [mouse-5] (t/lambda (scroll-up 2)))
  (mouse-wheel-mode t))
#+END_SRC

** Evil

*** Configuration

#+BEGIN_SRC emacs-lisp :results silent
(setq evil-want-C-d-scroll t
      evil-want-C-u-scroll t
      evil-want-keybinding nil
      evil-want-integration t
      evil-want-Y-yank-to-eol nil
      evil-move-beyond-eol t)

#+END_SRC

*** Init evil. Normal mode is default, and search using evil.

#+BEGIN_SRC emacs-lisp :results silent
(setq evil-default-state 'normal
      evil-insert-skip-empty-lines t
      evil-search-module 'evil-search)

(use-package evil
  :init
  (progn
    ;; https://emacs.stackexchange.com/a/15054
    (fset 'evil-visual-update-x-selection 'ignore)))

#+END_SRC

*** Show matches

Show current match and total number of matches when searching with evil.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-anzu
  :init
  (progn
    (setq anzu-cons-mode-line-p nil
          anzu-minimum-input-length 1
          anzu-search-threshold 100)))

#+END_SRC

*** jk to escape

Escape from evil with a fast ~jk~ combo.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-escape
  :after evil
  :init
  (progn
    (setq-default evil-escape-key-sequence "jk"
                  evil-escape-delay 0.1))
  :config
  (evil-escape-mode))

#+END_SRC

*** Evil leader

Use evil leader to provide a vim-like interface to useful shortcuts
using ~SPC~.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-leader
  :after evil
  :init
  (progn
    (setq evil-leader/in-all-states t
          evil-leader/non-normal-prefix t-emacs-leader))
  :config
  (progn
    (evil-leader/set-leader t-leader)
    (t/bind-in '(evil-normal-state-map evil-motion-state-map)
      "Y" 't/evil-yank-to-end-of-line)))

#+END_SRC

*** More evil bindings

Enables evil keybindings for more modes, e.g. help, calendar, eshell etc

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-collection
  :after evil
  :init
  (progn
    ;; Don't use zz and zq for org src editing
    (setq evil-collection-key-blacklist '("ZZ" "ZQ"))
    (evil-collection-init)
    (t/after org
      ;; still issues with wdired?
      ;; https://github.com/jtbm37/all-the-icons-dired/pull/19

      (evil-collection-define-key 'normal 'outline-mode-map (kbd "<tab>") 'org-cycle))))
#+END_SRC

*** Search

Jump between html tags with %, like for parens.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-matchit
  :commands evilmi-jump-items
  :config
  (global-evil-matchit-mode 1))

#+END_SRC

Visual followed by ~*~ or ~#~ allows for fast searching, forwards or backwards, for whats selected. Keep
hitting it to search further. Preserves selection.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-visualstar
  :commands (evil-visualstar/begin-search-forward
             evil-visualstar/begin-search-backward)
  :config
  (progn
    (setq evil-visualstar/persistent t)
    (global-evil-visualstar-mode)
    (t/bind-in 'evil-visual-state-map
      "*" 'evil-visualstar/begin-search-forward
      "#" 'evil-visualstar/begin-search-backward)))

#+END_SRC

*** Surroundings

Operate on surrounding parens, brackets etc like with surround.vim.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-surround
  :defer 1
  :config
  (progn
    (global-evil-surround-mode 1)
    ;; the opposite of vim, like spacemacs
    (evil-define-key 'visual evil-surround-mode-map "S" 'evil-substitute)
    (evil-define-key 'visual evil-surround-mode-map "s" 'evil-surround-region)))

#+END_SRC

*** Navigate parens

Helps navigating lisps, and makes evil operations, e.g. S-D (delete to end of
line) lisp aware, so it does not delete trailing parens.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-cleverparens
  :diminish evil-cleverparens-mode
  :defer 1
  :init
  (progn
    (t/add-hook-defun
     'evil-cleverparens-enabled-hook t-evil-cp-mode-hook
     (evil-define-key 'visual evil-cleverparens-mode-map (kbd "M-d") 'evil-multiedit-match-symbol-and-next)
     (evil-define-key 'normal evil-cleverparens-mode-map (kbd "M-d") 'evil-multiedit-match-symbol-and-next))
    (setq evil-cleverparens-use-additional-bindings t
          evil-cleverparens-use-regular-insert t))
  :config
  (t/after evil-surround
    (add-to-list 'evil-surround-operator-alist '(evil-cp-delete . delete))
    (add-to-list 'evil-surround-operator-alist '(evil-cp-change . change))))

#+END_SRC

*** Snipe

2-char motions for quickly jumping around text, compared to evil's built-in
f/F/t/T motions, incrementally highlighting candidate targets as you type. E.g.
hit fe to search for e's. Repeat f to move to the next e.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-snipe
  :defer 1
  :init
  (t/add-hook-defun 'prog-mode-hook t-hook-snipe
                    (evil-snipe-local-mode 1)
                    (evil-snipe-override-local-mode 1)))

#+END_SRC

*** Multiple cursors for evil mode.

It actually works. Added bindings M-j and M-k
skips current match forward or backward while moving through matches using M-d.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-multiedit
  :commands evil-multiedit-match-symbol-and-next
  :init
  (progn
    (setq evil-multiedit-follow-matches t)
    (t/bind-in 'evil-normal-state-map
      "M-d" 'evil-multiedit-match-symbol-and-next
      "C-M-r" 'evil-multiedit-restore))
  :config
  (progn
    (evil-multiedit-default-keybinds)
    (unbind-key "M-d" evil-insert-state-map)
    (unbind-key "C-M-D" evil-normal-state-map)
    (bind-key "gn" 'evil-multiedit--visual-line evil-multiedit-state-map)

    (progn
      (setq evil-multiedit-store-in-search-history t)

      (defun t/mc-skip-prev ()
        (interactive)
        (evil-multiedit-toggle-or-restrict-region)
        (evil-multiedit-match-and-prev))

      (defun t/mc-skip-next ()
        (interactive)
        (evil-multiedit-toggle-or-restrict-region)
        (evil-multiedit-match-and-next))

      (t/bind-in 'evil-multiedit-state-map
        "M-j" #'t/mc-skip-next
        "M-k" #'t/mc-skip-prev))))

#+END_SRC

*** Commentary

For effectively toggling comments on or off, or combining them
with vim text objects or other motions. E.g. use gca( to comment out the
surrounding lisp sexp, respecting the ast.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-commentary
  :defer 1
  :init (evil-commentary-mode))

#+END_SRC

*** Color highlights evil operations.

#+BEGIN_SRC emacs-lisp :results silent
(use-package evil-goggles
  :defer 1
  :init
  (setq evil-goggles-duration 0.2
        evil-goggles-async-duration 0.2
        evil-goggles-pulse t)
  :config
  (evil-goggles-mode)
  (evil-goggles-use-magit-faces))
#+END_SRC

*** Useful extra evil operators

- eval with ~gr~
- google search with ~gG~
- google translate with ~g.~
- highlight with ~gh~
- fold with ~gs~
- capture with ~go~

Highlight and fold-this are dependencies of evil-extra-operator.

#+BEGIN_SRC emacs-lisp :results silent
(use-package highlight)
(use-package fold-this :after highlight)
(use-package google-translate :after fold-this)
(use-package evil-extra-operator
  :after google-translate
  :defer 1
  :init
  (setq evil-extra-operator-org-capture-key "gC")
  :config
  (global-evil-extra-operator-mode 1))
#+END_SRC

*** Modes starting states; emacs state, insert, normal

#+BEGIN_SRC emacs-lisp :results silent
(defvar t-evil-major-modes '(compilation-mode
                             special-mode
                             calendar-mode
                             git-rebase-mode
                             diff-mode
                             gnus-group-mode
                             gnus-summary-mode)
  "Major modes that should trigger evil emacs state when changed to.")

(t/after evil
  (t/add-hook-defun 'after-change-major-mode-hook t/hook-major-mode
                    (when (member major-mode t-evil-major-modes)
                      (evil-emacs-state))))
#+END_SRC

Commit starts in insert mode

#+BEGIN_SRC emacs-lisp :results silent
(t/add-hook '(git-commit-mode-hook org-capture-mode-hook) 'evil-insert-state)
#+END_SRC

*** Cursors

#+BEGIN_SRC emacs-lisp :results silent
(defun t/init-evil-cursors (&rest _)
  "Change cursors after theme colors have loaded."
  (setq evil-default-cursor (face-background 'cursor nil t)
        evil-emacs-state-cursor  `(,(face-foreground 'warning) box)
        evil-normal-state-cursor 'box
        evil-insert-state-cursor 'bar
        evil-visual-state-cursor 'hollow))
(advice-add #'load-theme :after #'t/init-evil-cursors)

#+END_SRC

*** Esc escapes everything

Escape all the things. Borrowed from doom.

#+BEGIN_SRC emacs-lisp :results silent
(defvar +evil-esc-hook '(t)
  "A hook run after ESC is pressed in normal mode (invoked by
    `evil-force-normal-state'). If a hook returns non-nil, all hooks after it are
    ignored.")

(defun +evil*attach-escape-hook (&optional ignore)
  "Run all `+evil-esc-hook' hooks. If any returns non-nil, stop there."
  (cond (;; quit the minibuffer if open.
         (minibuffer-window-active-p (minibuffer-window))
         (abort-recursive-edit))
        ;; disable ex search buffer highlights.
        ((evil-ex-hl-active-p 'evil-ex-search)
         (evil-ex-nohighlight))
        ;; escape anzu number of matches
        ((and (featurep 'anzu)
              anzu--state)
         (anzu--reset-status))
        ;; remove highlights
        ((and (featurep 'highlight-symbol)
              highlight-symbol-mode)
         (highlight-symbol-remove-all))
        ;; Run all escape hooks. If any returns non-nil, then stop there.
        (t (run-hook-with-args-until-success '+evil-esc-hook))))
(advice-add #'evil-force-normal-state :after #'+evil*attach-escape-hook)

#+END_SRC

*** Help motions

#+BEGIN_SRC emacs-lisp :results silent
;; motions keys for help buffers
(evil-define-key 'motion help-mode-map (kbd "q") 'quit-window)
(evil-define-key 'motion help-mode-map (kbd "<tab>") 'forward-button)
(evil-define-key 'motion help-mode-map (kbd "S-<tab>") 'backward-button)
(evil-define-key 'motion help-mode-map (kbd "L") 'help-go-forward)
(evil-define-key 'motion help-mode-map (kbd "H") 'help-go-back)
(evil-define-key 'motion help-mode-map (kbd "gf") 'help-go-forward)
(evil-define-key 'motion help-mode-map (kbd "gb") 'help-go-back)
(evil-define-key 'motion help-mode-map (kbd "gh") 'help-follow-symbol)

#+END_SRC

*** Info motions

#+BEGIN_SRC emacs-lisp :results silent
;; motion keys for info mode
(evil-define-key 'normal Info-mode-map (kbd "H") 'Info-history-back)
(evil-define-key 'normal Info-mode-map (kbd "L") 'Info-history-forward)
(unbind-key (kbd "h") Info-mode-map)
(unbind-key (kbd "l") Info-mode-map)
#+END_SRC

*** C-o from hybrid like in vim

i_Ctrl-o - C-o from hybrid mode, like in vim insert mode

#+BEGIN_SRC emacs-lisp :results silent
(evil-define-key 'hybrid global-map (kbd "C-o") 'evil-execute-in-normal-state)
#+END_SRC

*** Useful emacs defaults

#+BEGIN_SRC emacs-lisp :results silent
;; some emacs stuff is useful, in terminals etc
;; http://stackoverflow.com/a/16226006
(t/bind-in '(evil-normal-state-map
             evil-insert-state-map
             evil-visual-state-map
             evil-motion-state-map)
  "C-a" 't/smart-beginning-of-line
  "C-e" 'end-of-line
  "C-b" 'evil-backward-char
  "C-f" 'evil-forward-char
  "C-k" 'kill-line
  "C-n" 'evil-next-line
  "C-p" 'evil-previous-line
  "C-w" 'evil-delete-backward-word
  "M-y" 'counsel-yank-pop)

(t/bind-in 'evil-insert-state-map
  "C-d" 'evil-delete-char
  "C-u" (t/lambda (kill-line 0)))

(t/bind-in '(evil-normal-state-map
             evil-visual-state-map)
  "Q" 'call-last-kbd-macro
  "C-y" 'evil-paste-pop ; cycle after pasting with p
  "C-S-y" (t/lambda (evil-paste-pop-next 1)))

(bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-map)
(bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-ns-map)
(bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-completion-map)
(bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-must-match-map)
(bind-key [escape] 'minibuffer-keyboard-quit minibuffer-local-isearch-map)

#+END_SRC

*** Preset registers

Turn camel case into snake case

#+BEGIN_SRC emacs-lisp :results silent
;; macro camelCase to snake_case
(evil-set-register ?c [?: ?s ?/ ?\\ ?\( ?\[ ?a ?- ?z ?0 ?- ?9 ?\] ?\\ ?\) ?\\ ?\( ?\[ ?A ?- ?Z ?0 ?- ?9 ?\] ?\\ ?\) ?/ ?\\ ?1 ?_ ?\\ ?l ?\\ ?2 ?/ ?g])
#+END_SRC

*** Text Objects

#+begin_src emacs-lisp :results silent
(t/after evil

  (evil-define-text-object evil-org-outer-subtree (count &optional beg end type)
    "An Org subtree.  Uses code from `org-mark-subtree`"
    :type line
    (save-excursion
      ;; get to the top of the tree
      (org-with-limited-levels
       (cond ((org-at-heading-p) (beginning-of-line))
             ((org-before-first-heading-p) (user-error "Not in a subtree"))
             (t (outline-previous-visible-heading 1))))

      (decf count)
      (when count (while (and (> count 0) (org-up-heading-safe)) (decf count)))

      ;; extract the beginning and end of the tree
      (let ((element (org-element-at-point)))
        (list (org-element-property :end element)
              (org-element-property :begin element)))))

  (evil-define-text-object evil-org-inner-subtree (count &optional beg end type)
    "An Org subtree, minus its header and concluding line break.  Uses code from `org-mark-subtree`"
    :type line
    (save-excursion
      ;; get to the top of the tree
      (org-with-limited-levels
       (cond ((org-at-heading-p) (beginning-of-line))
             ((org-before-first-heading-p) (user-error "Not in a subtree"))
             (t (outline-previous-visible-heading 1))))

      (decf count)
      (when count (while (and (> count 0) (org-up-heading-safe)) (decf count)))

      ;; extract the beginning and end of the tree
      (let* ((element (org-element-at-point))
             (begin (save-excursion
                      (goto-char (org-element-property :begin element))
                      (next-line)
                      (point)))
             (end (save-excursion
                    (goto-char (org-element-property :end element))
                    (backward-char 1)
                    (point))))
        (list end begin))))

  (evil-define-text-object evil-org-outer-item (count &optional beg end type)
    :type line
    (let* ((struct (org-list-struct))
           (begin (org-list-get-item-begin))
           (end (org-list-get-item-end (point-at-bol) struct)))
      (if (or (not begin) (not end))
          nil
        (list begin end))))

  (evil-define-text-object evil-org-inner-item (count &optional beg end type)
    (let* ((struct (org-list-struct))
           (begin (progn (goto-char (org-list-get-item-begin))
                         (forward-char 2)
                         (point)))
           (end (org-list-get-item-end-before-blank (point-at-bol) struct)))
      (if (or (not begin) (not end))
          nil
        (list begin end))))

  (define-key evil-outer-text-objects-map "*" 'evil-org-outer-subtree)
  (define-key evil-inner-text-objects-map "*" 'evil-org-inner-subtree)
  (define-key evil-inner-text-objects-map "-" 'evil-org-inner-item)
  (define-key evil-outer-text-objects-map "-" 'evil-org-outer-item))
#+end_src

** Which key

Some guidance is always welcome.

#+BEGIN_SRC emacs-lisp :results silent
(use-package which-key
  :diminish which-key-mode
  :init
  (progn
    (setq which-key-sort-order #'which-key-prefix-then-key-order
          which-key-sort-uppercase-first nil
          which-key-add-column-padding 1
          which-key-max-display-columns nil
          which-key-min-display-lines 1
          which-key-special-keys nil
          which-key-side-window-max-height 0.5 ; percentage height
          which-key-separator " "
          which-key-idle-delay 0.4 ; time to wait before display
          which-key-allow-evil-operators t
          which-key-key-replacement-alist
          '(("<\\([[:alnum:]-]+\\)>" . "\\1")
            ("up"                    . "↑")
            ("right"                 . "→")
            ("down"                  . "↓")
            ("left"                  . "←")
            ("DEL"                   . "⌫")
            ("deletechar"            . "⌦")
            ("RET"                   . "⏎")))))

#+END_SRC

Custom prefix functions for defining named shortcuts accessible through evil leader.

#+BEGIN_SRC emacs-lisp :results silent
(defun t/prefix-with-leader (key)
  "Prefixes `key' with `leader' and a space, e.g. 'SPC m'"
  (concat t-leader " " key))

(defun t/prefix-with-emacs-leader (key)
  "Prefixes `key' with emacs `leader' and a space, e.g. 'C-SPC m'"
  (concat t-emacs-leader t-leader " " key))

(defun t/declare-prefix (prefix name &optional key fn &rest bindings)
  "Declares which-key `prefix' and a display `name' for the prefix.
       Sets up keybindings for the prefix."
  (t/after which-key
    (which-key-declare-prefixes (t/prefix-with-leader prefix) name)
    (which-key-declare-prefixes (t/prefix-with-emacs-leader prefix) name)
    (while key
      (evil-leader/set-key (concat prefix key) fn)
      (setq key (pop bindings)
            fn (pop bindings)))))

(defun t/declare-prefix-for-mode (mode prefix name &optional key fn &rest bindings)
  "Declares which-key `prefix' and a display `name' for the prefix only in `mode`.
       Sets up keybindings for the prefix."
  (t/after which-key
    (which-key-declare-prefixes-for-mode mode (t/prefix-with-leader prefix) name)
    (which-key-declare-prefixes-for-mode mode (t/prefix-with-emacs-leader prefix) name)
    (while key
      (evil-leader/set-key-for-mode mode (concat prefix key) fn)
      (setq key (pop bindings)
            fn (pop bindings)))))

(defun t/micro-state-in-mode (mode key fn &rest bindings)
  "Micro state that temporarily overlays a new key map, kinda like hydra"
  (lexical-let ((keymap (make-sparse-keymap)))
    (while key
      (bind-key key fn keymap)
      (setq key (pop bindings)
            fn (pop bindings)))
    (lambda ()
      (interactive)
      (funcall mode)
      (set-temporary-overlay-map keymap t (lambda nil
                                            (funcall mode -1))))))
#+END_SRC

*** Evil leader + Which key integration

Turn on which key. For some reason evil must be turned off before global evil
leader will actually turn on evil-leader globally. Then turn on evil.

#+BEGIN_SRC emacs-lisp :results silent
(which-key-mode 1)
(t/declare-prefix "m" "Mode")
(evil-mode nil)
(global-evil-leader-mode)
(evil-mode 1)
#+END_SRC

** Calendar

#+BEGIN_SRC emacs-lisp :results silent
(use-package calendar
  :ensure nil
  :straight nil
  :commands calendar
  :init
  (setq calendar-week-start-day 1
        calendar-date-style 'iso))
#+end_src

Make it Norwegian.

#+begin_src emacs-lisp :results silent
(use-package calendar-norway
  :after calendar
  :config
  (progn
    (setq calendar-holidays
          (append calendar-norway-raude-dagar
                  calendar-norway-andre-merkedagar
                  calendar-norway-dst
                  '((holiday-fixed 3 17 "St. Patricksdag") ; extra non-no days
                    (holiday-fixed 10 31 "Hallowe'en")
                    (holiday-float 11 4 4 "Thanksgiving")
                    (solar-equinoxes-solstices)))
          calendar-day-name-array ["Søndag" "Mandag" "Tirsdag" "Onsdag" "Torsdag" "Fredag" "Lørdag"]
          solar-n-hemi-seasons '("Vårjevndøgn" "Sommersolverv" "Høstjevndøgn" "Vintersolherv"))

    (setq calendar-latitude lat-trh
          calendar-longitude lon-trh
          calendar-location-name loc-trh)

    ;; show week numbers in calendar
    (copy-face font-lock-constant-face 'calendar-iso-week-face)
    (set-face-attribute 'calendar-iso-week-face nil :height 1 :foreground "VioletRed1")

    (copy-face 'default 'calendar-iso-week-header-face)
    (set-face-attribute 'calendar-iso-week-header-face nil :height 0.5 :foreground "VioletRed4")

    (setq calendar-mark-holidays-flag t
          calendar-intermonth-header '(propertize " " 'font-lock-face 'calendar-iso-week-header-face)
          calendar-intermonth-text '(propertize (format "%2d" (car
                                                               (calendar-iso-from-absolute
                                                                (calendar-absolute-from-gregorian
                                                                 (list month day year)))))
                                                'font-lock-face 'calendar-iso-week-face))))
#+END_SRC

** Local Site lisp

Useful local copies of elisp programs.

#+BEGIN_SRC emacs-lisp :results silent
(use-package ox-gfm
  :ensure nil
  :straight nil
  :load-path "site-lisp/ox-gfm")

(use-package nxml-eldoc
  :ensure nil
  :straight nil
  :load-path "site-lisp/nxml-eldoc"
  :commands turn-on-nxml-eldoc
  :init
  (t/add-hook 'nxml-mode-hook 'turn-on-nxml-eldoc))

(use-package json-path-eldoc
  :ensure nil
  :straight nil
  :load-path "site-lisp/json-path-eldoc"
  :commands turn-on-json-path-eldoc
  :init
  (t/add-hook 'json-mode-hook 'turn-on-json-path-eldoc))

(use-package sgml-mode
  :ensure nil
  :straight nil
  :commands html-mode
  :init
  (progn
    (t/add-hook-defun 'sgml-mode-hook t/hook-sgml
                      (set (make-local-variable 'sgml-basic-offset) *t-indent*))))

(use-package nxml-mode
  :ensure nil
  :straight nil
  :mode "\\.\\(xml\\|svg\\|rss\\|xsd\\|xslt\\|plist\\)$"
  :config
  ;; reindent after deleting tag with C-c DEL
  (defadvice sgml-delete-tag (after reindent activate)
    (indent-region (point-min) (point-max)))

  ;; nxml
  (setq nxml-child-indent *t-indent-xml*))

(use-package html
  :ensure nil
  :straight nil
  :mode ("\\.\\(html|htm\\)" . html-mode))

(use-package imenu-list
  :ensure nil
  :straight nil
  :load-path "site-lisp/imenu-list"
  :init
  (progn
    (setq imenu-list-auto-resize t)
    (t/after evil
      (add-to-list 'evil-emacs-state-modes 'imenu-list-minor-mode))
    (t/after imenu-list
      (bind-key "j" 'next-line imenu-list-major-mode-map)
      (bind-key "k" 'previous-line imenu-list-major-mode-map))
    (t/add-hook-defun 'imenu-list-update-hook t-after-imenu-update
                      (with-current-buffer imenu-list-buffer-name
                        (text-scale-set 0)
                        (text-scale-decrease 3)))))
  #+END_SRC

No longer in use.

#+BEGIN_SRC emacs-lisp :results silent
(use-package cloudformation-mode
  :if nil ; id stay away from cloud formation tbh
  :ensure nil
  :straight nil
  :load-path "site-lisp/cloudformation-mode")

(use-package spotify
  :if nil ; no longer works after the deprecated spotify api
  :ensure nil
  :straight nil
  :load-path "site-lisp/spotify")
#+END_SRC

** Ivy

Trying ivy as a helm replacement. https://news.ycombinator.com/item?id=24449883

These three actually seem to replace all my previous helm config 😱

#+BEGIN_SRC emacs-lisp :results silent
(use-package counsel :init (ivy-mode 1))
(use-package counsel-projectile)
(use-package counsel-web)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
;; TODO Is there a counsel-wiki?
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
(use-package counsel-etags
  :if nil ; try without it
  :bind (("C-]" . counsel-etags-find-tag-at-point))
  :init
  (t/add-hook 'prog-mode-hook
              (t/lambda
                  (add-hook 'after-save-hook
                            'counsel-etags-virtual-update-tags 'append 'local)))
  :config
  (setq counsel-etags-update-interval 60)
  (push "build" counsel-etags-ignore-directories)
  (push "target" counsel-etags-ignore-directories))
#+END_SRC

** VC

*** Gutter/fringe

Show git status in the gutter.

#+BEGIN_SRC emacs-lisp :results silent
(use-package git-gutter+
  :diminish git-gutter+-mode
  :init
  (t/add-hook 'prog-mode-hook 'git-gutter+-mode)
  :config
  (progn
    (evil-add-command-properties #'git-gutter+-next-hunk :jump t)
    (evil-add-command-properties #'git-gutter+-previous-hunk :jump t)
    (setq git-gutter+-modified-sign "~"
          git-gutter+-added-sign "+"
          git-gutter+-deleted-sign "-"
          git-gutter+-separator-sign (if has-gui "" " "))))

(use-package git-gutter-fringe+
  :init
  (t/add-hook-defun 'git-gutter+-mode-hook t/hook-git-gutter+
                    (fringe-helper-define 'git-gutter-fr+-added '(top repeat) "XXX.....")
                    (fringe-helper-define 'git-gutter-fr+-deleted '(top repeat) "XXX.....")
                    (fringe-helper-define 'git-gutter-fr+-modified '(top repeat) "XXX.....")
                    (git-gutter+-enable-fringe-display-mode)))
#+END_SRC

*** Links

Open link to line under version control on github.com

#+BEGIN_SRC emacs-lisp :results silent
(use-package git-link
  :commands git-link
  :init
  (setq git-link-open-in-browser t))

#+END_SRC

Open link to region under version control on github.com

#+BEGIN_SRC emacs-lisp :results silent
(use-package browse-at-remote
  :init
  (setq browse-at-remote-add-line-number-if-no-region-selected nil))
#+END_SRC

Super useful package to skip through time in version control using C-n and C-p.
Git blame is shown for each hunk as you navigate.

*** Blame

#+BEGIN_SRC emacs-lisp :results silent
(use-package git-timemachine
  :commands git-timemachine-toggle
  :config
  (defadvice git-timemachine-mode (after toggle-evil activate)
    (when git-timemachine-mode
      (t/bind-in 'evil-normal-state-local-map
        "q" 'git-timemachine-quit
        "C-g" 'git-timemachine-quit
        "C-n" 'git-timemachine-show-next-revision
        "C-p" 'git-timemachine-show-previous-revision))))

#+END_SRC

*** Gist

A gist interface for emacs.

#+BEGIN_SRC emacs-lisp :results silent
(use-package gist
  :commands (gist-list
             gist-buffer
             gist-buffer-private
             gist-region
             gist-region-private))
#+END_SRC

*** Magit and Forge

The only git client you will ever need.

#+BEGIN_SRC emacs-lisp :results silent
(use-package magit
  :commands magit-status
  :init
  (progn
    (setq magit-pull-arguments nil
          magit-fetch-arguments '("--prune")
          magit-rebase-arguments '("--interactive")
          magit-log-arguments '("--graph" "--color" "--decorate" "-n256")
          magit-display-buffer-function 'magit-display-buffer-same-window-except-diff-v1)
    (when is-mac
      (setq
       ;; fixes https://github.com/magit/ghub/issues/81 - dont use this on linux
       gnutls-algorithm-priority "NORMAL:-VERS-TLS1.3"

       ;; https://github.com/magit/ghub/issues/81
       ;; https://github.com/magit/ghub/commit/785cbfd1d48559556f38e9be7c3ed9bc15af12eb
       ghub-use-workaround-for-emacs-bug 'force)))
  :config
  (progn
    (bind-key "q" #'magit-quit-session magit-status-mode-map)

    (t/add-hook 'magit-log-mode-hook 'visual-line-mode)
    (t/add-hook 'magit-diff-mode-hook 'visual-line-mode)

    (defadvice magit-blame-mode (after switch-to-emacs-mode activate)
      (if magit-blame-mode
          (evil-emacs-state 1)
        (evil-normal-state 1)))

    (defun magit-quit-session ()
      "Restores the previous window configuration and kills the magit buffer"
      (interactive)
      (kill-buffer)
      (git-gutter+-refresh))))
#+END_SRC

A pull request interface for emacs.

#+BEGIN_SRC emacs-lisp :results silent
(use-package forge :after magit)
#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp :results silent
(t/declare-prefix "g" "Git"
                  "T" 'git-timemachine-toggle
                  "s" 'magit-status
                  "b" 'magit-blame
                  "d" 'magit-diff
                  "l" 'magit-log-current
                  "L" 'magit-log
                  "C" 'magit-commit-create
                  "c" #'t/clone)

(t/declare-prefix "gh" "Hunk"
                  "n" 'git-gutter+-next-hunk
                  "N" 'git-gutter+-previous-hunk
                  "C" 'git-gutter+-stage-and-commit
                  "?" 'git-gutter+-show-hunk-inline-at-point
                  "=" 'git-gutter+-show-hunk
                  "r" 'git-gutter+-revert-hunks
                  "s" 'git-gutter+-stage-hunks
                  "cc" 'magit-commit-create
                  "ca" 'magit-commit-amend)

(t/declare-prefix "go" "Open github"
                  ;; TODO if region active choose gob
                  "l" 'git-link
                  "b" 'browse-at-remote)

(t/declare-prefix "gg" "Gist"
                  "l" 'gist-list
                  "b" 'gist-buffer
                  "B" 'gist-buffer-private
                  "r" 'gist-region
                  "R" 'gist-region-private)
#+END_SRC

** Editor

*** Restart

Make testing emacs initialization easier.

#+begin_src emacs-lisp :results silent
(use-package restart-emacs
  :commands restart-emacs
  :init
  (t/declare-prefix "q" "Quit"
                    "d" 't/safe-restart-emacs
                    "r" (t/lambda (restart-emacs))
                    "R" (t/lambda (restart-emacs '("--no-desktop")))))
#+end_src

*** Unique buffer names

Add dir to buffer names when they're not unique.

#+BEGIN_SRC emacs-lisp :results silent
(use-package uniquify
  :ensure nil
  :straight nil
  :init
  (progn
    (setq uniquify-buffer-name-style 'forward)))

#+END_SRC

*** Beacon to show the cursor

#+BEGIN_SRC emacs-lisp :results silent
(use-package beacon
  :defer 1
  :if nil ; no longer use it
  :init
  (setq beacon-size 10
        beacon-blink-delay 0
        beacon-blink-duration 0.25
        beacon-color "#f06")
  :config (beacon-mode))
#+END_SRC

*** Subword are words

Useful for programming

#+BEGIN_SRC emacs-lisp :results silent
(use-package subword
  :diminish subword-mode
  :defer 1
  :ensure nil
  :straight nil
  :config (subword-mode))
#+END_SRC

*** SSH like its local files

#+BEGIN_SRC emacs-lisp :results silent
(use-package tramp
  :defer t
  :ensure nil
  :straight nil
  :init
  (t/add-hook-setq 'eshell-mode-hook
                   tramp-default-method "ssh"
                   tramp-auto-save-directory (locate-user-emacs-file ".tramp-auto-save")))

#+END_SRC

*** Directory browser

#+BEGIN_SRC emacs-lisp :results silent
(use-package dired
  :ensure nil
  :straight nil
  :commands (dired dired-jump)
  :init
  (progn
    (put 'dired-find-alternate-file 'disabled nil)
    (setq wdired-allow-to-change-permissions t)
    (setq dired-auto-revert-buffer t
          dired-listing-switches "-alhF"
          dired-ls-F-marks-symlinks "@"
          dired-use-ls-dired nil
          dired-dwim-target t))
  :config
  (progn
    (bind-key "C-x C-j" 'dired-jump)
    (bind-key "C-c C-e" 'dired-toggle-read-only)
    (bind-key "C-x M-j" (t/lambda (dired-jump 1)))
    (evil-define-key 'normal dired-mode-map "u" (t/lambda (find-alternate-file "..")))
    (t/bind-in 'dired-mode-map
      "e" 't/eshell
      "C-d" 'dired-kill-subdir
      "~" (t/lambda (find-alternate-file "~"))
      "M-<up>" (t/lambda (find-alternate-file ".."))
      "M-p" (t/lambda (find-alternate-file ".."))
      "M-<down>" (t/lambda (dired-find-alternate-file))
      "M-n" (t/lambda (dired-find-alternate-file)))))

#+END_SRC

*** Local dired extensions

#+BEGIN_SRC emacs-lisp :results silent
(use-package dired-hacks-utils
  :hook dired-mode-hook
  :ensure nil
  :straight nil
  :load-path "site-lisp/dired-hacks-utils")

  #+END_SRC

**** Browse archives

#+BEGIN_SRC emacs-lisp :results silent
(use-package dired-avfs
  :hook dired-mode-hook
  :ensure nil
  :straight nil
  :load-path "site-lisp/dired-avfs")
#+END_SRC

**** Details

#+BEGIN_SRC emacs-lisp :results silent
(use-package dired-details
  :hook dired-mode-hook
  :ensure nil
  :straight nil
  :load-path "site-lisp/dired-details"
  :init
  (progn
    (setq dired-details-hidden-string "")
    (add-hook 'dired-mode-hook 'dired-hide-details-mode)))

#+END_SRC

**** Toggle folders

#+BEGIN_SRC emacs-lisp :results silent
(use-package dired-subtree
  :commands dired-subtree-toggle
  :ensure nil
  :straight nil
  :load-path "site-lisp/dired-subtree/"
  :init
  (t/after dired
    (setq dired-subtree-line-prefix "  ")
    (bind-key (kbd "<tab>") 'dired-subtree-toggle dired-mode-map)))

#+END_SRC

**** Pretty icons

#+BEGIN_SRC emacs-lisp :results silent
(use-package all-the-icons-dired
  :commands all-the-icons-dired-mode
  :init
  (t/add-hook 'dired-mode-hook 'all-the-icons-dired-mode))
#+END_SRC

*** Colorize

Colorize inline colors.

#+BEGIN_SRC emacs-lisp :results silent
(use-package rainbow-mode
  :diminish rainbow-mode
  :commands rainbow-mode
  :init
  (t/add-hook '(prog-mode-hook css-mode-hook html-mode-hook) 'rainbow-mode))
#+END_SRC

Colorize delimiters.

#+BEGIN_SRC emacs-lisp :results silent
(use-package rainbow-delimiters
  :commands rainbow-delimiters-mode
  :init
  (t/add-hook 'prog-mode-hook 'rainbow-delimiters-mode))

#+END_SRC

*** Directory tree

#+BEGIN_SRC emacs-lisp :results silent
(use-package neotree
  :commands (neotree-toggle
             neotree-show
             neotree-hide
             neotree-find)
  :init
  (progn
    (setq neo-smart-open nil
          neo-window-fixed-size nil
          neo-window-width 35
          neo-create-file-auto-open t
          neo-mode-line-type 'none
          neo-force-change-root t
          neo-theme 'icons
          neo-show-updir-line nil
          neo-show-hidden-files nil
          neo-auto-indent-point t)
    (t/add-hook-defun 'neotree-mode-hook t/neotree-hook
                      (evil-commentary-mode -1)
                      (evil-extra-operator-mode -1)
                      (hl-line-mode))
    (t/after neotree
      (add-to-list 'window-size-change-functions ;; fixes: https://github.com/jaypei/emacs-neotree/issues/262
                   (lambda (frame)
                     (let ((neo-window (neo-global--get-window)))
                       (unless (null neo-window)
                         (setq neo-window-width (window-width neo-window))))))))
  :config
  (progn
    (bind-key [f6] 'neotree-toggle)
    (dolist (key '(("n" . neotree-next-line)
                   ("p" . neotree-previous-line)
                   ("C-n" . neotree-next-line)
                   ("C-p" . neotree-previous-line)
                   ("c" . neotree-create-node)
                   ("R" . neotree-rename-node)
                   ("D" . neotree-delete-node)
                   ("i" . neotree-enter-horizontal-split)
                   ("C-c o" . neotree-enter-vertical-split)
                   ("s" . neotree-enter-vertical-split)
                   ("g" . neotree-refresh)
                   ("u" . neotree-select-up-node)
                   ("M-<up>" . neotree-select-up-node)
                   ("I" . neotree-hidden-file-toggle)
                   ("q" . neotree-hide)
                   ("q" . neotree-hide)
                   ("v" . neotree-quick-look)
                   ("TAB" . neotree-enter)
                   ("RET" . neotree-enter)
                   ("M-<down>" . neotree-enter)
                   ("C" . neotree-change-root)))
      (eval `(evil-define-key 'normal neotree-mode-map (kbd ,(car key)) ',(cdr key))))))

#+END_SRC

*** Jump

**** Jump between windows

#+BEGIN_SRC emacs-lisp :results silent
(use-package ace-window :commands ace-window)
#+END_SRC

**** Jump to char, chars, lines

#+BEGIN_SRC emacs-lisp :results silent
(use-package avy
  :commands (avy-goto-char
             avy-goto-char-2
             avy-goto-line
             avy-goto-char-in-line
             avy-goto-word-0
             avy-goto-line-above
             avy-goto-word-0-above
             avy-goto-word-1-above
             avy-goto-char-2-above
             avy-goto-symbol-1-above
             avy-goto-line-below
             avy-goto-word-0-below
             avy-goto-word-1-below
             avy-goto-char-2-below
             avy-goto-symbol-1-below)
  :init
  (progn
    (setq avy-keys '(?j ?f ?d ?k ?s ?a)
          avy-timeout-seconds 0.2
          avy-all-windows 'all-frames
          avy-case-fold-search nil
          avy-highlight-first t
          avy-style 'at-full
          avy-background t))
  :config
  (progn
    (let ((f 'font-lock-function-name-face))
      (set-face-attribute 'avy-lead-face nil   :background nil :foreground (face-foreground f))
      (set-face-attribute 'avy-lead-face-0 nil :background nil :foreground (face-foreground f))
      (set-face-attribute 'avy-lead-face-1 nil :background nil :foreground (face-foreground f))
      (set-face-attribute 'avy-lead-face-2 nil :background nil :foreground (face-foreground f)))))

#+END_SRC

**** Jump ace

#+BEGIN_SRC emacs-lisp :results silent
(use-package ace-jump-mode
  :commands (ace-jump-mode
             ace-jump-char-mode
             ace-jump-line-mode
             ace-jump-word-mode)
  :init
  (progn
    (setq ace-jump-mode-gray-background t
          ace-jump-mode-case-fold t)))

#+END_SRC

*** REST

**** Restclient

A fantastic rest client interface for emacs.

#+BEGIN_SRC emacs-lisp :results silent
(use-package restclient :mode ("\\.\\(http\\|rest\\)$" . restclient-mode))
#+END_SRC

**** Elasticsearch

A rest client interface for elasticsearch, similar to restclient

#+BEGIN_SRC emacs-lisp :results silent
(use-package es-mode
  :commands es-mode
  :init
  (progn
    (defun t/es-mode-format (status header buffer)
      (with-current-buffer buffer
        (json-pretty-print-buffer)))
    (setq es-response-success-functions '(t/es-mode-format)))
  :config
  (t/bind-in 'es-mode-map
    "C-c C-v" 'es-execute-request-dwim))
#+END_SRC

*** Folding

#+BEGIN_SRC emacs-lisp :results silent
(use-package hideshow
  :commands evil-toggle-fold
  :ensure nil
  :straight nil
  :init
  (progn
    (add-hook 'prog-mode-hook 'hs-minor-mode)
    (defun display-code-line-counts (ov)
      (when (eq 'code (overlay-get ov 'hs))
        (overlay-put ov
                     'display (format " ... "
                                      (count-lines (overlay-start ov)
                                                   (overlay-end ov))))))
    (setq hs-set-up-overlay #'display-code-line-counts)))
#+END_SRC

*** Undo

#+BEGIN_SRC emacs-lisp :results silent
(use-package undo-tree
  :diminish undo-tree-mode
  :commands undo-tree-visualize
  :init
  (progn
    (setq undo-tree-auto-save-history nil
          undo-tree-visualizer-timestamps t
          undo-tree-visualizer-diff t)
    (t/declare-prefix "a" "Applications"
                      "u" 'undo-tree-visualize)))

#+END_SRC

*** Fun

**** Reddit

#+BEGIN_SRC emacs-lisp :results silent
(use-package md4rd
  :init
  (progn
    (t/add-hook 'md4rd-mode-hook 'md4rd-indent-all-the-lines)
    (t/after evil
      (t/after md4rd
        (progn
          (evil-define-key 'normal md4rd-mode-map (kbd "q") 'kill-current-buffer)
          (evil-define-key 'normal md4rd-mode-map (kbd "<tab>") 'tree-mode-toggle-expand)
          (evil-define-key 'normal md4rd-mode-map (kbd "u") 'tree-mode-goto-parent)
          (evil-define-key 'normal md4rd-mode-map (kbd "j") 'widget-forward)
          (evil-define-key 'normal md4rd-mode-map (kbd "k") 'widget-backward)
          (evil-define-key 'normal md4rd-mode-map (kbd "M-q") 'md4rd-indent-all-the-lines)
          (evil-define-key 'normal md4rd-mode-map (kbd "c") 'md4rd-widget-collapse-all)
          (evil-define-key 'normal md4rd-mode-map (kbd "t") 'md4rd-widget-toggle-line)
          (evil-define-key 'normal md4rd-mode-map (kbd "e") 'md4rd-widget-expand-all)
          (evil-define-key 'normal md4rd-mode-map (kbd "o") (t/lambda nil
                                                              (forward-word)
                                                              (md4rd-open)))
          (evil-define-key 'normal md4rd-mode-map (kbd "<return>") 'md4rd-visit)
          (evil-define-key 'normal md4rd-mode-map (kbd "v") 'md4rd-visit)
          (evil-define-key 'normal md4rd-mode-map (kbd "M-u") 'md4rd-upvote)
          (evil-define-key 'normal md4rd-mode-map (kbd "d") 'md4rd-downvote))))
    (setq md4rd-subs-active '(MechanicalKeyboards emacs clojure))))

#+END_SRC

*** Smex

Not nescessary after installing counsel?

#+BEGIN_SRC emacs-lisp :results silent
(use-package smex
  :if nil ; no longer need after counsel?
  :commands (smex smex-major-mode-commands)
  :init
  (progn
    (setq smex-flex-matching t
          smex-save-file (locate-user-emacs-file ".smex-items")))
  :config
  (progn
    (t/bind-in 'global-map
      "C-x C-m" 'smex
      "C-c C-M" 'smex-major-mode-commands)
    (smex-initialize)))

#+END_SRC

*** Completion

Useful backends.

#+BEGIN_SRC emacs-lisp :results silent
(defun t/company-backends (&optional backends)
  `((,@backends
     company-files
     company-keywords
     company-capf
     company-yasnippet
     company-emoji)
    (company-dabbrev-code
     company-dabbrev
     company-abbrev)))
#+END_SRC

Complete with company.

#+BEGIN_SRC emacs-lisp :results silent
(use-package company
  :commands company-complete
  :init
  (progn
    (setq company-idle-delay 0.15
          company-tooltip-align-annotations t
          company-tooltip-flip-when-above nil
          company-show-numbers t ; nav with m-<n>
          company-selection-wrap-around t
          company-tooltip-minimum-width 30
          company-tooltip-margin 1
          company-require-match nil
          company-backends (t/company-backends '()))
    (t/after company
      (t/bind-in 'company-active-map
        "TAB" 'company-complete-selection
        "RET" 'company-complete-selection
        "C-w" 'evil-delete-backward-word
        "C-l" 'evil-delete-backward-word
        "C-u" 'backward-kill-sentence
        "C-h" 'company-show-doc-buffer
        "C-n" 'company-select-next
        "C-s" 'company-search-candidates
        "C-p" 'company-select-previous
        "C-," #'t/company-helm)
      (defun t/company-helm ()
        (interactive)
        (company-abort)
        (completion-at-point))
      (global-company-mode))))

#+END_SRC

Company frontend with icons.

#+BEGIN_SRC emacs-lisp :results silent
(use-package company-box
  :commands company-box-mode
  :init
  (progn
    (setq company-box-doc-delay 0.05
          company-box-backends-colors nil)
    (t/after company-box
      (add-to-list 'company-box-frame-parameters '(desktop-dont-save . t))
      (add-to-list 'company-box-doc-frame-parameters '(desktop-dont-save . t)))
    (t/add-hook-defun 'company-mode-hook t/company-box-mode-hook
                      (setq company-box-icons-alist 'company-box-icons-all-the-icons)
                      (company-box-mode))))

#+END_SRC

Fuzzy search.

#+BEGIN_SRC emacs-lisp :results silent
(use-package company-flx
  :after company
  :config
  (progn
    (company-flx-mode +1)))

#+END_SRC

Html, web, jade etc.

#+BEGIN_SRC emacs-lisp :results silent
(use-package company-web :after company)
#+END_SRC

Rest client completions.

#+BEGIN_SRC emacs-lisp :results silent
(use-package company-restclient
  :commands restclient-mode
  :config
  (t/add-company-backends-hook 'restclient-mode-hook 'company-restclient))

;; TODO
;; counsel xref replace helm-xref

;; TODO
;; counsel unicode replace helm-unicode
#+END_SRC

Emoji completions.

#+BEGIN_SRC emacs-lisp :results silent
(use-package company-emoji :commands company-mode :after company)
#+END_SRC

Insert emojis, literally.

#+BEGIN_SRC emacs-lisp :results silent
(use-package emoji-cheat-sheet-plus
  :commands (emoji-cheat-sheet-plus-insert)
  :init
  (progn
    (t/declare-prefix "a" "applications"
                      "e" 'emoji-cheat-sheet-plus-insert
                      "U" 'helm-unicode))
  :config
  (progn
    ;; make `emoji-cheat-sheet-plus' insert unicodes 🎉
    (defvar t-emoji-cheat-sheet-plus-use-unicode t)

    (defun t/emoji-cheat-shet-plus--unicode-for-emoji-text (text)
      (let* ((emojis (company-emoji-list-create))
             (ret (-first
                   (lambda (emoji)
                     (let ((emoji-text (t/strip-text-properties emoji)))
                       (equal emoji-text text)))
                   emojis)))
        (when ret
          (get-text-property 0 :unicode ret))))

    (defun emoji-cheat-sheet-plus--insert-selection (_)
      "Override to insert the selected emojis into the buffer."
      (let ((emojis (company-emoji-list-create)))
        (dolist (c (helm-marked-candidates))
          (save-match-data
            (string-match "\:.+?\:" c)
            (let ((emoji (match-string 0 c)))
              (insert
               (if t-emoji-cheat-sheet-plus-use-unicode
                   (t/emoji-cheat-shet-plus--unicode-for-emoji-text emoji)
                 emoji)))))))))

#+END_SRC

*** Parens

Lispy paren-like ast editing for other modes as well.

#+BEGIN_SRC emacs-lisp :results silent
(use-package smartparens
  :diminish smartparens-mode
  :commands turn-on-smartparens-mode
  :init
  (progn
    (t/after smartparens
      (setq sp-ignore-modes-list (delete 'minibuffer-inactive-mode sp-ignore-modes-list)))

    (sp-use-paredit-bindings)

    ;; TODO torgeir
    ;; interfers with e.g. org-mode, enable them specifically in lisp modes instead
    (unbind-key "M-?" sp-keymap)
    (comment (unbind-key "M-<up>" sp-keymap)
             (unbind-key "M-<down>" sp-keymap)
             (unbind-key "C-<right>" sp-keymap)
             (unbind-key "C-<left>" sp-keymap))

    (t/bind-in 'sp-keymap
      ;; sp bindings
      "C-M-f" 'sp-forward-sexp
      "C-M-b" 'sp-backward-sexp
      "C-M-d" 'sp-down-sexp
      "C-M-S-d" 'sp-backward-down-sexp
      "C-M-a" 'sp-beginning-of-sexp
      "C-M-e" 'sp-end-of-sexp
      "C-M-S-e" 'sp-up-sexp
      "C-M-u" 'sp-backward-up-sexp
      "C-M-n" 'sp-next-sexp
      "C-M-p" 'sp-previous-sexp
      "C-M-k" 'sp-kill-sexp
      "C-M-w" 'sp-copy-sexp

      ;; paredit bindings
      "<delete>" 'sp-delete-char
      "<backspace>" 'sp-backward-delete-char
      "C-<right>" #'sp-forward-slurp-sexp
      "C-<left>" #'sp-forward-barf-sexp
      "M-<up>" 'sp-splice-sexp-killing-backward
      "M-<down>" 'sp-splice-sexp-killing-forward

      ;; extras
      "M-S-<up>" #'sp-backward-up-sexp
      "M-S-<down>" #'sp-down-sexp
      "M-S-<left>" #'sp-backward-sexp
      "M-S-<right>" #'sp-next-sexp)

    (t/bind-in 'global-map
      "s-(" 't/wrap-with-parens
      "s-)" 't/paredit-wrap-round-from-behind
      "M-s-(" 't/wrap-with-braces
      "M-s-[" 't/wrap-with-brackets)

    (bind-key "RET" #'t/newline-expand-braces)

    (t/add-hook '(js-mode-hook
                  text-mode-hook
                  restclient-mode-hook
                  rjsx-mode
                  ruby-mode
                  mark-down-mode
                  es-mode-hook) 'turn-on-smartparens-mode)

    ;; enable in minibuffer
    (t/add-hook 'eval-expression-minibuffer-setup-hook #'(turn-on-smartparens-mode evil-cleverparens-mode))

    (defun t/enable-movement-for-lisp-mode (m)
      (lexical-let* ((mode (symbol-name m))
                     (mode-hook (intern (concat mode "-hook")))
                     (mode-map (intern (concat mode "-map"))))
        (add-hook mode-hook 'turn-on-smartparens-mode)
        (add-hook mode-hook 'evil-cleverparens-mode)))

    (t/after elisp-mode (t/enable-movement-for-lisp-mode 'emacs-lisp-mode))
    (t/after ielm (t/enable-movement-for-lisp-mode 'ielm-mode))
    (t/after clojure-mode (t/enable-movement-for-lisp-mode 'clojure-mode))

    (dolist (mode '(emacs-lisp-mode clojure-mode ielm-mode minibuffer-inactive-mode))
      (sp-local-pair mode "`" nil :actions nil)
      (sp-local-pair mode "'" nil :actions nil))

    (sp-with-modes 'emacs-lisp-mode
      (sp-local-pair "`" "'" :when '(sp-in-docstring-p)))

    (t/def-pairs ((paren . "(")
                  (bracket . "[")
                  (brace . "{")
                  (single-quote . "'")
                  (double-quote . "\"")
                  (back-quote . "`"))))
  :config
  (progn
    (t/bind-in 'text-mode-map
      "C-<right>" 'sp-forward-slurp-sexp
      "C-<left>" 'sp-forward-barf-sexp)))

#+END_SRC

*** CSV

Edit csv, transpose columns, delete columns, sort

#+BEGIN_SRC emacs-lisp :results silent
(use-package csv-mode
  :commands csv-mode
  :init
  (setq csv-separators '(";")))
#+END_SRC

*** Distraction free

#+BEGIN_SRC emacs-lisp :results silent
(use-package writeroom-mode
  :commands (global-writeroom-mode turn-on-writeroom-mode writeroom-mode)
  :init
  (setq writeroom-width 0.60
        writeroom-mode-line t
        writeroom-maximize-window t
        writeroom-fullscreen-effect nil
        writeroom-major-modes
        '(js-mode
          js2-mode
          rjsx-mode
          emacs-lisp-mode
          dired-mode
          eshell-mode
          all-the-icons-dired-mode
          ruby-mode)))

#+END_SRC

*** Web browser

**** eww

An elisp web browser.

***** Readable

Eww functions that directly enter the eww readability mode normally available
from pressing R in eww mode.

#+BEGIN_SRC emacs-lisp :results silent
(defun t/eww-readable-after-render (&optional fn)
  (lambda (status url buffer)
    (eww-render status url nil buffer)
    (switch-to-buffer buffer)
    (eww-readable)
    (writeroom-mode 1)
    (let ((content (buffer-substring-no-properties (point-min) (point-max))))
      (read-only-mode 0)
      (erase-buffer)
      (insert content)
      (beginning-of-buffer)
      (when fn (funcall fn)))))

(defun t/eww-readable (url &optional fn)
  (interactive "sEnter URL: ")
  (lexical-let ((buffer (get-buffer-create "*eww*")))
    (with-current-buffer buffer
      (autoload 'eww-setup-buffer "eww")
      (eww-setup-buffer)
      (url-retrieve url (t/eww-readable-after-render fn) (list url buffer)))))

#+END_SRC

***** Images and wrap long lines

#+BEGIN_SRC emacs-lisp :results silent
(t/after shr
  ;; don't truncate lines in eww-mode
  ;;(setq shr-width nil)
  (defun shr-fill-text (text) text)
  (defun shr-fill-lines (start end) nil)
  (defun shr-fill-line () nil)

  ;; wrap lines
  (t/add-hook-defun 'eww-after-render-hook t/hook-eww-trunc
                    (toggle-truncate-lines -1)))

;; not to large images
(setq shr-use-fonts nil
      shr-max-image-proportion 0.6
      shr-ignore-cache t)

#+END_SRC

***** Open from chrome

Opens the frontmost chrome url in eww.

#+BEGIN_SRC emacs-lisp :results silent
(defun t/visit-frontmost-chrome-url-in-eww ()
  "Visit the front-most url of chrome in eww."
  (interactive)
  (eww (t/grab-chrome-url)))
#+END_SRC

***** Hook and keybindings

#+BEGIN_SRC emacs-lisp :results silent
(t/after eww
  (t/add-hook-defun 'eww-mode-hook t/hook-eww
                    (t/declare-prefix-for-mode 'eww-mode
                                               "t" "Toggle"
                                               "i" 't/eww-toggle-images)
                    (t/bind-in '(evil-normal-state-local-map)
                      "q" 'quit-window
                      "S-TAB" 'shr-previous-link
                      "TAB" 'shr-next-link
                      "R" 'eww-readable
                      "M-p" 'backward-paragraph
                      "M-n" 'forward-paragraph
                      "s-l" 'eww)
                    (visual-line-mode)))
#+END_SRC

**** w3m

Another text based web browser

#+BEGIN_SRC emacs-lisp :results silent
(use-package w3m
  :commands w3m
  :config
  (t/bind-in 'w3m-mode-map
    "M-p" 'backward-paragraph
    "M-n" 'forward-paragraph))
#+END_SRC

*** Major modes

#+BEGIN_SRC emacs-lisp :results silent
(use-package discover-my-major
  :commands (discover-my-major discover-my-mode))

#+END_SRC

*** Old helm config - TODO port bindings to ivy?

#+BEGIN_SRC emacs-lisp :results silent
(comment
 use-package helm
  :commands (completion-at-point
             helm
             helm-mini
             helm-projectile
             helm-projectile-ag
             helm-projectile-rg)
  :diminish helm-mode
  :config
  (progn
    (require 'helm-config)
    (t/after helm
      (t/bind-in 'helm-map
        "C-w" 'backward-kill-word
        "C-u" 'backward-kill-sentence
        "C-c u" 'universal-argument))
    (t/after helm-command
      (t/bind-in 'helm-M-x-map
        "C-w" 'backward-kill-word
        "C-u" 'backward-kill-sentence
        "C-c u" 'universal-argument))
    (t/after helm-files
      (t/bind-in 'helm-find-files-map
        "M-<down>" 'helm-execute-persistent-action
        "M-<up>" 'helm-find-files-up-one-level
        "C-k" 'helm-find-files-up-one-level))
    (setq-default helm-candidate-number nil
                  helm-display-header-line nil
                  helm-M-x-fuzzy-match t
                  helm-apropos-fuzzy-match t
                  helm-buffers-fuzzy-matching t
                  helm-completion-in-region-fuzzy-match t
                  helm-file-cache-fuzzy-match t
                  helm-lisp-fuzzy-completion t
                  helm-mode-fuzzy-match t
                  helm-projectile-fuzzy-match t
                  helm-recentf-fuzzy-match t
                  helm-candidate-number-limit 100
                  helm-prevent-escaping-from-minibuffer t
                  helm-always-two-windows t
                  helm-echo-input-in-header-line t
                  helm-follow-mode-persistent t ; keep follow mode on, after on once
                  helm-ff-skip-boring-files t
                  helm-quick-update t
                  helm-M-x-requires-pattern nil
                  helm-show-completion-display-function #'helm-show-completion-default-display-function)

    (require 'helm-mode)
    (helm-mode 1)
    (t/add-hook-defun 'helm-after-initialize-hook t/hide-cursor-in-helm-buffer
                      (with-helm-buffer
                        (setq cursor-in-non-selected-windows nil)))
    (set-face-attribute 'helm-source-header nil :height 1)
    (t/after neotree
      (t/add-hook 'helm-before-initialize-hook 'neotree-hide))))

#+END_SRC

*** GNUS

#+BEGIN_SRC emacs-lisp :results silent
(use-package nnhackernews)
#+END_SRC

*** External documentation

#+BEGIN_SRC emacs-lisp :results silent
(use-package dash-at-point
  :commands dash-at-point)

;; (use-package expand-region
;;   :commands (er/expand-region er/contract-region)
;;   :init
;;   (progn
;;     (bind-key (if is-mac "M-@" "M-'") 'er/expand-region)
;;     (bind-key (if is-mac "M-*" "M-§") 'er/contract-region)))

#+END_SRC

*** Snippets

#+BEGIN_SRC emacs-lisp :results silent
(use-package yasnippet
  :diminish yas-minor-mode
  :defer 1
  :init
  (progn
    (setq yas-snippet-dirs '(t-dir-snippets)
          ;; remove dropdowns
          ;;yas-prompt-functions '(yas-ido-prompt yas-completing-prompt)
          yas-verbosity 0
          yas-wrap-around-region t))
  :config
  (progn
    (yas-global-mode)

    (defun t/yas-clear-or-delete-char ()
      "Replace `yas-next-field' with noop `+' to make <backspace> only clear or delete-char."
      (interactive)
      (cl-letf (((symbol-function 'yas-next-field) #'+))
        (call-interactively 'yas-skip-and-clear-or-delete-char)))
    (bind-key "<backspace>" #'t/yas-clear-or-delete-char yas-keymap)

    (t/add-hook-defun 'after-save-hook t/reload-autoloads-on-defuns-save
                      (when (string-match "\\t-defuns.el$" buffer-file-name)
                        (eval-buffer)
                        (t/reload-autoloads)
                        (message "Reloaded autoloads.")))
    (t/add-hook-defun 'after-save-hook t/reload-snippets-on-save
                      (t/when-ext "yasnippet" (yas-reload-all)))

    ;; make fundamental snippets global snippets
    (t/add-hook-defun 'yas-minor-mode-hook t/hook-yas (yas-activate-extra-mode 'fundamental-mode))

    ;; jump to end of snippet definition
    (bind-key "<return>" 'yas-exit-all-snippets yas-keymap)

    ;; inter-field navigation
    (defun yas/goto-end-of-active-field ()
      (interactive)
      (let* ((snippet (car (yas--snippets-at-point)))
             (position (yas--field-end (yas--snippet-active-field snippet))))
        (if (= (point) position)
            (move-end-of-line 1)
          (goto-char position))))

    (defun yas/goto-start-of-active-field ()
      (interactive)
      (let* ((snippet (car (yas--snippets-at-point)))
             (position (yas--field-start (yas--snippet-active-field snippet))))
        (if (= (point) position)
            (move-beginning-of-line 1)
          (goto-char position))))

    (t/bind-in 'yas-keymap
      "C-e" 'yas/goto-end-of-active-field
      "C-a" 'yas/goto-start-of-active-field)))

#+END_SRC

*** Reload buffers on external change

#+BEGIN_SRC emacs-lisp :results silent
(use-package autorevert
  :ensure nil
  :straight nil
  :defer t
  :init
  (progn
    (setq auto-revert-interval 1
          ;; silenced refresh of dired
          auto-revert-verbose nil
          global-auto-revert-non-file-buffers t))
  :config
  (progn
    (global-auto-revert-mode)
    (when is-mac
      ;; file notifications aren't supported on os x
      (setq auto-revert-use-notify nil))))

#+END_SRC

*** Scrolling

#+BEGIN_SRC emacs-lisp :results silent
(use-package smooth-scrolling
  :commands (previous-line next-line isearch-repeat)
  :init
  (progn
    (setq smooth-scroll-margin 4
          mouse-wheel-progressive-speed nil ;; don't accelerate scrolling
          mouse-wheel-follow-mouse 't))
  :config
  (progn
    (smooth-scrolling-mode)
    (enable-smooth-scroll-for-function previous-line)
    (enable-smooth-scroll-for-function next-line)
    (enable-smooth-scroll-for-function isearch-repeat)))
#+END_SRC

*** Highlight

**** Parens

#+BEGIN_SRC emacs-lisp :results silent
(use-package highlight-parentheses
  :diminish highlight-parentheses-mode
  :defer 1
  :init
  (progn
    (setq hl-paren-colors (-repeat 26 "DeepPink"))
    (t/add-hook-defun 'prog-mode-hook t-hook-l-parens
                      (highlight-parentheses-mode)
                      (set-face-foreground 'show-paren-match "Green"))))
#+END_SRC

**** Escape sequences

#+BEGIN_SRC emacs-lisp :results silent
(use-package highlight-escape-sequences
  ;; what the 
  :hook (prog-mode-hook hes-mode)
  :config
  (progn
    (put 'hes-escape-backslash-face 'face-alias 'font-lock-comment-face)
    (put 'hes-escape-sequence-face 'face-alias 'font-lock-comment-face)))
#+END_SRC

**** Symbols

#+BEGIN_SRC emacs-lisp :results silent
(use-package highlight-symbol
  :diminish highlight-symbol-mode
  :commands (highlight-symbol-mode
             highlight-symbol
             highlight-symbol-next
             highlight-symbol-prev)
  :init
  (progn
    (setq highlight-symbol-idle-delay 0.5)
    (t/add-hook 'prog-mode-hook 'highlight-symbol-mode))
  :config
  ;; highlight-symbol uses hl-line-face
  (require 'hl-line))
#+END_SRC

**** Numbers

#+BEGIN_SRC emacs-lisp :results silent
(use-package highlight-numbers
  :defer 1
  :init
  (t/add-hook 'prog-mode-hook 'highlight-numbers-mode))
#+END_SRC

*** Codemods

**** Js
#+BEGIN_SRC emacs-lisp :results silent
(use-package js-codemod
  ;; :ensure nil
  ;; :straight nil
  ;; :load-path "~/Code/js-codemod/js-codemod.el"
  :commands (js-codemod-mod-region))
#+END_SRC

**** Old helm js codemod

#+BEGIN_SRC emacs-lisp :results silent
(comment
use-package helm-js-codemod
  ;; :ensure nil
  ;; :straight nil
  ;; :load-path "~/Code/js-codemod/helm-js-codemod.el"
  :commands (helm-js-codemod)
  :init
  (progn
    (setq helm-js-codemod-mod-dir
          (expand-file-name (t/user-emacs-file "js-codemods/")))
    (t/after which-key
      (t/declare-prefix "mr" "Refactor" "m" 'helm-js-codemod))))
#+END_SRC

*** News

**** Nrk.no

A custom function to fetch a clean view of the current news from nrk.no

#+BEGIN_SRC emacs-lisp :results silent
(defun t/clean-nrk-buffer ()
  (flush-lines "^$")
  ;; clean up lines beginning with dates, e.g. 20. sept...
  (beginning-of-buffer)
  (flush-lines "^[0-9][0-9]\.")
  ;; clean up lines beginning with -
  (beginning-of-buffer)
  (while (re-search-forward "*" nil t)
    ;; kill lines with dates, all these news are new
    (when (string-match-p "^* [0-9][0-9]\." (thing-at-point 'line))
      (kill-line)
      (forward-line)
      (join-line))
    ;; change * to -
    (replace-match "\n-")
    ;; highlight the line
    (add-text-properties (point-at-bol) (point-at-eol) '(face outline-4)))
  (beginning-of-buffer)
  (kill-line)
  (evil-search "- " t)
  (lexical-let ((keymap (make-sparse-keymap)))
    (bind-key "n" (t/lambda nil
                    (evil-search "- " t)
                    (recenter nil)) keymap)
    (bind-key "p" (t/lambda nil
                    (evil-search "- " nil)
                    (recenter nil)) keymap)
    (set-temporary-overlay-map keymap t)))

#+END_SRC

**** Hackernews

#+BEGIN_SRC emacs-lisp :results silent
(use-package hackernews
  :commands hackernews
  :init
  (defun t/hackernews ()
    "Open hackernews in current window."
    (interactive)
    (cl-letf (((symbol-function 'pop-to-buffer) #'switch-to-buffer))
      (call-interactively 'hackernews)))
  :config
  (progn
    (t/add-hook-defun 'hackernews-mode-hook t-hackernews-hook
                      (lexical-let ((keymap (make-sparse-keymap)))
                        (bind-key "n" 'hackernews-next-item keymap)
                        (bind-key "p" 'hackernews-previous-item keymap)
                        (bind-key "<return>" 'hackernews-button-browse-internal keymap)
                        (set-temporary-overlay-map keymap t)))
    (evil-define-key 'normal hackernews-map
      (kbd "<return>") 'hackernews-button-browse-internal
      (kbd "TAB") 'hackernews-next-comment
      "q" 'quit-window
      "j" 'hackernews-next-item
      "k" 'hackernews-previous-item
      "gr" 'hackernews-load-more-stories
      "gR" 'hackernews-reload)))

#+END_SRC

*** Complete lines - TODO implement for counsel

#+BEGIN_SRC emacs-lisp :results silent
;; TODO
;; redo it for counsel?
(comment
 use-package helm-lines
 :commands helm-lines
 :init
 (progn
   (setq helm-lines-project-root-function 't/project-root)
   (t/declare-prefix "c" "Comment/Complete"
                     "l" 'helm-lines)))

#+END_SRC

*** Command decompiler

#+BEGIN_SRC emacs-lisp :results silent
(use-package suggest :commands suggest)

#+END_SRC

*** Recent files

Save more recent files.

#+BEGIN_SRC emacs-lisp :results silent
(use-package recentf
  :ensure nil
  :straight nil
  :defer 1
  :init
  (progn
    (setq recentf-max-saved-items 1000
          recentf-auto-cleanup 'never))
  :config
  (progn
    (defun t/recentf-save-if-recentf-mode ()
      (when recentf-mode (recentf-save-list)))
    (t/idle-timer recentf-auto-save-timer #'t/recentf-save-if-recentf-mode 1)
    (recentf-mode 1)))

#+END_SRC

*** Line numbers

Toggles line numbers on or off.

#+BEGIN_SRC emacs-lisp :results silent
(use-package nlinum
  :commands nlinum-mode
  :init
  (setq nlinum-format " %d "))
#+END_SRC

Toggles relative line numbers, like in vim.

#+BEGIN_SRC emacs-lisp :results silent
(use-package nlinum-relative
  :commands nlinum-relative-toggle
  :init
  (setq nlinum-relative-redisplay-delay 0))

#+END_SRC

*** Projects

#+BEGIN_SRC emacs-lisp :results silent
(use-package projectile
  :diminish projectile-mode
  :commands (projectile-mode
             helm-projectile
             projectile-project-root
             projectile-relevant-known-projects
             projectile-load-known-projects)
  :init
  (progn
    (setq projectile-completion-system 'helm
          projectile-require-project-root nil
          projectile-known-projects-file (locate-user-emacs-file ".cache/projectile.projects")
          projectile-cache-file (locate-user-emacs-file ".cache/projectile.cache")
          projectile-enable-caching t
          projectile-project-root-files '(".git" ".hg" ".svn" ".project" "package.json" "setup.py" "Gemfile" "build.gradle")))
  :config
  (progn
    (t/add-to-list 'projectile-globally-ignored-directories '(".git" "elpy" "elpa-backups" "node_modules" ".idea"))
    (t/add-to-list 'projectile-globally-ignored-files '("package-lock.json" "*.bundle.js" "*.build.js" ".DS_Store" "projectile.cache" "custom.el"))
    (t/add-to-list 'grep-find-ignored-files '("package-lock.json" "*.bundle.js" "*.build.js" ".DS_Store" "projectile.cache" "custom.el" "node_modules/*" "elpy/*" "js-codemods/*" "target/*" "elpa-backups/*"))
    (projectile-global-mode +1)))
#+END_SRC

*** Dump jump

#+BEGIN_SRC emacs-lisp :results silent
(use-package dumb-jump
  :commands dumb-jump-go
  :init
  (progn
    (setq dumb-jump-selector 'helm)
    (t/bind-in '(evil-normal-state-map evil-insert-state-map)
      "M-." 'dumb-jump-go
      "M-." 'dumb-jump-go)

    (t/add-hook-defun 'emacs-lisp-mode-hook t/hook-elisp
                      (bind-key "M-." 'xref-find-definitions evil-normal-state-map)
                      (bind-key "M-." 'xref-find-definitions evil-insert-state-map))))

#+END_SRC

*** Intent

Force indents, like you mean it.

#+BEGIN_SRC emacs-lisp :results silent
(use-package aggressive-indent
  :commands (aggressive-indent-mode global-aggressive-indent-mode)
  :init
  (progn
    (t/add-hook-defun 'json-mode-hook t/hook-aggressive-indent-json (aggressive-indent-mode 0))
    (t/add-hook-defun 'js-mode-hook t/hook-aggressive-indent-js (aggressive-indent-mode 0))
    (t/add-hook-defun 'elm-mode-hook t/hook-aggressive-indent-js (aggressive-indent-mode 0))
    (t/add-hook-defun 'js2-mode-hook t/hook-aggressive-indent-js2 (aggressive-indent-mode 0))
    (t/add-hook-defun 'css-mode-hook t/hook-aggressive-indent-css (aggressive-indent-mode 0))
    (t/add-hook 'prog-mode-hook 'aggressive-indent-mode)
    (t/declare-prefix "t" "Toggle"
                      "a" 'aggressive-indent-mode)))

#+END_SRC

*** Whitespace

Clean out whitespace when saving.

#+BEGIN_SRC emacs-lisp :results silent
(use-package whitespace
  :ensure nil
  :straight nil
  :init
  (progn
    (t/add-hook 'before-save-hook 'whitespace-cleanup)
    (t/add-hook-defun '(prog-mode-hook text-mode-hook git-commit-mode-hook) t/hook-whitespace
                      (setq-local whitespace-style '(face tabs tab-mark trailing))
                      (whitespace-mode 1))))

#+END_SRC

*** Word count

#+BEGIN_SRC emacs-lisp :results silent
(use-package wc-mode :commands wc-mode)

#+END_SRC

*** Document viewer

View pdfs etc.

#+BEGIN_SRC emacs-lisp :results silent
(use-package doc-view
  :defer t
  :ensure nil
  :straight nil
  :init
  (setq doc-view-continuous t)
  :config
  (t/after evil
    (evil-set-initial-state 'doc-view-mode 'normal)
    (evil-make-overriding-map doc-view-mode-map 'normal)
    (evil-define-key 'normal doc-view-mode-map
      "gg" 'doc-view-first-page
      "G" 'doc-view-last-page
      "H" 'doc-view-fit-height-to-window
      "W" 'doc-view-fit-width-to-window
      "+" 'doc-view-enlarge
      "-" 'doc-view-shrink
      "/" (t/lambda () (let ((current-prefix-arg 4)) (call-interactively 'doc-view-search)))
      "?" (t/lambda () (let ((current-prefix-arg 4)) (call-interactively 'doc-view-search-backward)))
      "n" 'doc-view-search-next-match
      "p" 'doc-view-search-previous-match
      "j" 'doc-view-next-line-or-next-page
      "k" 'doc-view-previous-line-or-previous-page
      "q" (t/lambda () (doc-view-kill-proc) (quit-window)))
    (t/bind-in 'doc-view-mode-map
      "C-u" 'doc-view-scroll-down-or-previous-page
      "C-d" 'doc-view-scroll-up-or-next-page)))
#+END_SRC

*** Drawing

Draw inside emacs. Yes, you read correctly.

#+BEGIN_SRC emacs-lisp :results silent
(use-package artist-mode
  :ensure nil
  :straight nil
  :defer t
  :commands (t/artist-mode artist-mode)
  :init
  (progn
    (defun t/artist-mode ()
      (interactive)
      (if (and (boundp 'artist-mode)
               artist-mode)
          (progn
            (artist-mode-off)
            (evil-normal-state))
        (progn
          (switch-to-buffer "*scratch*")
          (aggressive-indent-mode 0)
          (evil-insert-state)
          (artist-mode t))))

    (t/add-hook-defun 'artist-mode-hook t/hook-artist
                      (t/bind-in '(evil-normal-state-local-map evil-insert-state-local-map)
                        "q" 'artist-mode-off))

    (t/after evil-leader
      (t/declare-prefix "aa" "drawing"
                        "t" #'t/artist-mode
                        "p" 'artist-select-op-pen-line
                        "l" 'artist-select-op-line
                        "r" 'artist-select-op-rectangle
                        "c" 'artist-select-op-circle
                        "e" 'artist-select-op-ellipse
                        "s" 'artist-select-op-square))))
#+END_SRC

*** Dictionary

#+BEGIN_SRC emacs-lisp :results silent
(use-package dictionary
  :if nil
  :commands (dictionary dictionary-search)
  :init
  (t/declare-prefix "s" "dictionary"
                    "dd" (t/lambda (dictionary-search (t/word-at-point)))))

#+END_SRC

Thesaurus.

#+BEGIN_SRC emacs-lisp :results silent
(use-package synosaurus
  :if nil
  :commands synosaurus-lookup
  :init
  (progn
    (setq synosaurus-choose-method 'popup
          synosaurus-backend 'synosaurus-backend-wordnet)
    (t/declare-prefix "s" "dictionary"
                      "ds" (t/lambda (synosaurus-lookup (t/word-at-point))))))
#+END_SRC

*** Eval overlays cider

#+BEGIN_SRC emacs-lisp :results silent
(progn
  ;; inline evaled results when in elisp using cider
  (autoload 'cider--make-result-overlay "cider-overlays")
  (defun endless/eval-overlay (value point)
    (cider--make-result-overlay (format "%S" value) :where point :duration 'command) value) ; preserve the return value
  (advice-add 'eval-region :around (lambda (f beg end &rest r) (endless/eval-overlay (apply f beg end r) end)))
  (advice-add 'eval-last-sexp :filter-return (lambda (r) (endless/eval-overlay r (point))))
  (advice-add 'eval-defun :filter-return (lambda (r) (endless/eval-overlay r (save-excursion (end-of-defun) (point))))))
  #+END_SRC

*** Misc text modes

#+BEGIN_SRC emacs-lisp :results silent
(t/add-hook 'text-mode-hook 'auto-fill-mode) ; wrap text in text modes
(t/add-hook 'text-mode-hook 'goto-address-prog-mode) ; navigate urls
(t/add-hook 'focus-out-hook #'garbage-collect) ; make it feel snappier
(t/add-hook 'before-save-hook #'delete-trailing-whitespace nil t)
(t/add-hook 'find-file 't/find-file-check-make-large-file-read-only-hook)
(setq large-file-warning-threshold (* 20 ; mb
                                      1024 1024))
#+END_SRC

*** Misc commands

#+BEGIN_SRC emacs-lisp :results silent
(evil-leader/set-key "'" 't/eshell)
(evil-leader/set-key "<" 't/eshell)
(evil-leader/set-key "|" 't/eshell)
(evil-leader/set-key "TAB" 't/switch-to-previous-buffer)
(evil-leader/set-key "u" 'universal-argument)
#+END_SRC

*** Regex editor

#+BEGIN_SRC emacs-lisp :results silent
(t/after re-builder (setq reb-re-syntax 'rx))
(defvar t-regex-mode nil "reb-mode on or not")
(defun t/toggle-regex-mode ()
  (interactive)
  (if t-regex-mode (reb-quit) (re-builder))
  (setq t-regex-mode (not t-regex-mode)))
#+END_SRC

*** Diffing

#+BEGIN_SRC emacs-lisp :results silent
(t/add-hook 'ediff-keymap-setup-hook
            (t/lambda (define-key ediff-mode-map "d" 't/ediff-use-both)))
#+END_SRC

*** Keybindings
#+BEGIN_SRC emacs-lisp :results silent
(t/declare-prefix "a" "Applications"
                  "B" 'w3m
                  "c" 'calendar
                  "b" #'t/browse-url-at-point
                  "C" 'calc-dispatch
                  "d" 'md4rd
                  "g" 'gnus
                  "h" 't/hackernews
                  "i" 't/open-in-intellij
                  "p" 'proced
                  "m" 'popwin:messages
                  "M" (t/lambda nil (switch-to-buffer "*Messages*") (end-of-buffer))
                  "n" (t/lambda (t/eww-readable "https://www.nrk.no/nyheter/" 't/clean-nrk-buffer))
                  "R" #'t/toggle-regex-mode
                  "se" 't/eshell
                  "st" 'ansi-term
                  "sT" 'term
                  "ss" 'shell
                  "S" 'suggest
                  "w" 'eww
                  "W" (t/lambda nil
                        (t/eww-readable "https://en.wikipedia.org/wiki/Special:Random")
                        (visual-line-mode -1)
                        (visual-line-mode 1)))

(t/declare-prefix "fe" "Editor")

(t/declare-prefix "fe" "Files"
                  "R" 't/config-reload
                  "i" 't/helm-files-emacs-init-files)

(t/declare-prefix "fep" "Packages"
                  "i" 'package-install
                  "r" 'package-refresh-contents
                  "l" 'paradox-list-packages
                  "R" 'package-reinstall
                  "U" 't/upgrade-packages)

(t/declare-prefix "t" "Toggle"
                  "D" 'toggle-debug-on-error
                  "f" 't/cycle-font
                  "dd" 'darkroom-mode
                  "dt" 'darkroom-tentative-mode
                  "F" 'toggle-frame-fullscreen
                  "t" 't/load-theme-cycle
                  "T" 't/transparency
                  "m" 'imenu-list-smart-toggle
                  "M" 'menu-bar-mode
                  "n" #'t/toggle-line-numbers
                  "r" 'nlinum-relative-toggle
                  "L" 'hl-line-mode
                  "l" 'visual-line-mode
                  "." 'whitespace-mode
                  "W" 'global-writeroom-mode
                  "w" 'writeroom-mode
                  "Cc" 'rainbow-mode
                  "Cd" 'rainbow-delimiters-mode)

(t/declare-prefix "b" "Buffers"
                  "S" 'save-some-buffers
                  "s" 't/switch-to-scratch-buffer
                  "d" 'kill-this-buffer
                  "t" 't/kill-other-buffers
                  "b" 'helm-mini
                  "o" 't/switch-to-previous-buffer
                  "p" 'popwin:display-buffer
                  "n" 'next-buffer
                  "R" 'revert-buffer)

(t/declare-prefix "d" "Doc/Desktop"
                  "d" 'dash-at-point
                  "S" 'dash-at-point-with-docset
                  "s" #'t/desktop-save
                  "r" #'t/desktop-restore
                  "c" 'desktop-clear)

(t/declare-prefix "x" "Text manipulation"
                  "a" 'align-regexp
                  "k" 'ido-kill-buffer
                  "m" 'helm-M-x
                  "x" 'smex-major-mode-commands
                  "ls" 't/sort-lines
                  "lu" 't/uniquify-lines)

(t/declare-prefix "xt" "Transpose"
                  "c" 'transpose-chars
                  "w" 'transpose-words
                  "l" 'transpose-lines
                  "f" 'transpose-frame
                  "s" 'transpose-sexps
                  "S" 'transpose-sentences
                  "p" 'transpose-paragraphs)

(t/declare-prefix "r" "Registers"
                  "r" 'evil-show-registers)

(t/declare-prefix "f" "Files/Frame"
                  "b" 'helm-bookmarks
                  "f" 'helm-find-files
                  "l" 't/neotree-open-file
                  "L" 'neotree-hide
                  "j" 'dired-jump
                  "J" 'dired-jump-other-window
                  "d" 'delete-frame
                  "g" 'ffap
                  "o" 't/open-in-desktop
                  "r" 'helm-recentf)

(t/declare-prefix "h" "Help"
                  "h" #'t/describe
                  "f" #'t/face-at-point
                  "F" #'list-faces-display
                  "C" #'list-colors-display
                  "a" 'helm-apropos
                  "l" 'helm-locate-library
                  "i" 'helm-info-at-point
                  "I" 'helm-info
                  "r" 'helm-resume
                  "db" 'helm-descbinds
                  "dd" 'dash-at-point
                  "df" 'describe-function
                  "dk" 'describe-key-briefly
                  "dK" 'describe-key
                  "dc" 'describe-char
                  "dm" 'describe-mode
                  "dM" 'describe-minor-mode
                  "dt" 'describe-theme
                  "dp" 'describe-package
                  "dv" 'describe-variable)

(t/declare-prefix "e" "Errors"
                  "c" 'flycheck-clear
                  "p" 'flycheck-previous-error
                  "n" 'flycheck-next-error
                  "N" 'flycheck-previous-error
                  "l" 'flycheck-list-errors
                  "v" 'flycheck-verify-setup
                  "t" 'flycheck-mode)

(t/declare-prefix "w" "Windows"
                  "h" 'windmove-left
                  "j" 'windmove-down
                  "k" 'windmove-up
                  "l" 'windmove-right
                  "n" 'make-frame-command
                  "D" 't/delete-frame-or-hide-last-remaining-frame
                  "d" 'delete-window
                  "t" 'delete-other-windows
                  "o" 't/previous-window
                  "=" 'balance-windows-area
                  "-" 'evil-window-decrease-width
                  "+" 'evil-window-increase-width
                  "u" 'winner-undo
                  "R" 'winner-redo
                  "r" 'transpose-frame)

(t/declare-prefix "z" "Folding"
                  "z" 'hs-toggle-hiding
                  "f" 'hs-hide-block
                  "F" 'hs-hide-all
                  "r" 'hs-show-block
                  "R" 'hs-show-all)

(t/declare-prefix "j" "Jump to"
                  "f" 'find-function
                  "k" 'find-function-on-key
                  "p" (lambda (key)
                        (interactive "kPress keybinding to run in popup: ")
                        (popwin:display-buffer-1 (popwin:dummy-buffer))
                        (let ((keys (key-binding key)))
                          (funcall
                           (cond ((stringp keys) (symbol-function keys))
                                 (t keys)))))
                  "w" 'ace-window
                  "j" 'avy-goto-char-timer
                  "t" 'avy-goto-char-timer
                  "c" 'avy-goto-char
                  "C" 'avy-goto-char-2
                  "l" 'avy-goto-line
                  "L" 'avy-goto-char-in-line
                  "W" 'avy-goto-word-1)

(t/declare-prefix "ja" "Jump to above"
                  "l" 'avy-goto-line-above
                  "W" 'avy-goto-word-0-above
                  "w" 'avy-goto-word-1-above
                  "c" 'avy-goto-char-2-above
                  "s" 'avy-goto-symbol-1-above)

(t/declare-prefix "jb" "Jump to below"
                  "l" 'avy-goto-line-below
                  "w" 'avy-goto-word-1-below
                  "W" 'avy-goto-word-0-below
                  "c" 'avy-goto-char-2-below
                  "s" 'avy-goto-symbol-1-below)

(t/declare-prefix "h" "Highlight"
                  "H" (t/lambda (highlight-symbol (thing-at-point 'symbol)))
                  "n" 'highlight-symbol-next
                  "N" 'highlight-symbol-prev)

(t/declare-prefix "p" "Project"
                  "b" 'helm-browse-project
                  "c" 'projectile-switch-project
                  "d" 't/projectile-dired
                  "w" #'t/projectile-desktop
                  "f" 'helm-projectile
                  "F" 'projectile-find-file-dwim
                  "g" 't/projectile-magit-status
                  "G" 'projectile-regenerate-tags
                  "k" 'projectile-kill-buffers
                  "l" 't/neotree-open-file
                  "L" 'neotree-hide
                  "o" 't/open-in-desktop
                  "p" 't/projectile-visit-git-link-pulls
                  "r" 't/projectile-helm-rg
                  "s" 't/projectile-helm-ag
                  "R" 'projectile-replace
                  "S" 'projectile-save-project-buffers
                  "t" 'projectile-find-test-file)

(t/declare-prefix "s" "Search"
                  "I" 'helm-imenu-in-all-buffers
                  "T" 'helm-etags-select
                  "a" 'helm-multi-swoop-all
                  "b" 'helm-ag-buffers
                  "f" 'helm-ag-this-file
                  "g" 'helm-google
                  "G" 'helm-google-suggest
                  "m" 'helm-imenu
                  "i" 'lsp-find-implementation
                  "r" 'lsp-find-references
                  "d" 'lsp-find-definition
                  "D" 'lsp-find-declaration
                  "r" 'helm-projectile-rg
                  "p" 'helm-projectile-ag
                  "s" 'swiper-helm
                  "t" 'etags-select-find-tag-at-point
                  "w" 'helm-wikipedia-suggest)
#+end_src
*** Popups

#+BEGIN_SRC emacs-lisp :results silent
(use-package popwin
  :defer 1
  :init
  (progn
    (setq popwin:popup-window-height 25))
  :config
  (popwin-mode 1)
  (add-to-list 'popwin:special-display-config "*xref*")
  (add-to-list 'popwin:special-display-config '("*cider-doc*" :noselect t)))
#+END_SRC

** Languages

#+begin_src emacs-lisp :results silent
(require 't-lang-arduino)
(require 't-lang-applescript)
(require 't-lang-clojure)
(require 't-lang-css)
(require 't-lang-docker)
(require 't-lang-elisp)
(require 't-lang-elm)
(require 't-lang-gitconfig)
(require 't-lang-gitignore)
(require 't-lang-graphql)
(require 't-lang-haskell)
(require 't-lang-js)
(require 't-lang-json)
(require 't-lang-flycheck)
(require 't-lang-kotlin)
(require 't-lang-markdown)
(require 't-lang-pug)
(require 't-lang-php)
(require 't-lang-remark)
(require 't-lang-scala)
(require 't-lang-sh)
(require 't-lang-html)
(require 't-lang-yaml)
(require 't-lang-terraform)
#+end_src

** Shell

#+begin_src emacs-lisp :results silent
;; (use-package bash-completion
;;   :commands bash-completion-dynamic-complete
;;   :init
;;   (progn
;;     (autoload 'bash-completion-dynamic-complete "bash-completion" "BASH completion hook")
;;     (t/add-hook 'shell-dynamic-complete-functions 'bash-completion-dynamic-complete)))

;; (use-package native-complete
;;   :init
;;   (with-eval-after-load 'shell (native-complete-setup-bash)))

(use-package esh-help
  :commands setup-esh-help-eldoc
  :init
  (t/add-hook 'eshell-first-time-mode-hook 'setup-esh-help-eldoc))

(use-package esh-autosuggest
  :init
  (t/add-hook 'eshell-mode-hook 'esh-autosuggest-mode)
  :config
  (t/bind-in 'esh-autosuggest-active-map "C-j" 'company-complete-selection))

(use-package eshell-z
  :init
  (t/add-hook-defun 'eshell-mode-hook t/eshell-z-hook (require 'eshell-z)))

(progn

  (progn
    ;; shell
    (defun t/shell-mode-kill-buffer-on-exit (process state)
      (shell-write-history-on-exit process state)
      (when (string-match "\\(finished\\|exited\\)" (buffer-string))
        (kill-buffer-and-window)))

    (defun t/shell-mode-hook ()
      (set-process-sentinel (get-buffer-process (current-buffer))
                            #'t/shell-mode-kill-buffer-on-exit))

    (t/add-hook 'shell-mode-hook #'t/shell-mode-hook))

  (progn
    ;; term
    (setq explicit-shell-file-name "/bin/zsh")

    (defun t/term-mode-hook ()
      (defun term-window-width () 2000)
      (setq truncate-lines t)
      (t/highlight-logging)
      (evil-define-key 'normal term-raw-map "M-:" 'eval-expression)
      (evil-define-key 'normal term-raw-map "p" 'term-paste)
      (evil-define-key 'insert term-raw-map (kbd "<tab>") 'term-send-tab)

      (defun t/term-try-quit ()
        (interactive)
        (t/term-quit-if-finished 'term-send-eof))

      (t/bind-in '(evil-normal-state-local-map evil-insert-state-local-map)
        "C-d" 't/term-try-quit))

    (t/add-hook 'term-mode-hook #'t/term-mode-hook))

  (comment
   ;; ansi-term
   (defun t/ansi-term-mode-hook ()
     "Close current term buffer when `exit' or c-d from term buffer."
     (goto-address-mode)

     (when (ignore-errors (get-buffer-process (current-buffer)))
       (set-process-sentinel
        (get-buffer-process (current-buffer))
        (lambda (proc change)
          (message change)
          (when (string-match "\\(finished\\|exited\\)" change)
            (kill-buffer (process-buffer proc)))))))

   (t/add-hook 'term-mode-hook #'t/ansi-term-mode-hook)

   (defconst t-term-name "/bin/zsh")
   (defadvice ansi-term (before force-bash)
     (interactive (list t-term-name))
     (term-line-mode))
   (ad-activate 'ansi-term)

   (defadvice ansi-term (after always-use-line-mode)
     (term-line-mode))
   (ad-activate 'ansi-term)

   ;; fix tab-completion
   (t/add-hook-setq 'term-mode-hook yas-dont-activate t))

  (progn
    ;; eshell

    (defun t/eshell-init ()
      "Init eshell."
      (t/add-hook-defun 'eshell-first-time-mode-hook t/hook-init-eshell
                        (t/eshell-init-smart)
                        (t/eshell-init-aliases)

                        ;; fix wierd prompts
                        (add-to-list 'eshell-preoutput-filter-functions
                                     (lambda (output)
                                       (replace-regexp-in-string "\\[[0-9]+[G-K]" "" output))))

      (setq eshell-history-size 10000
            eshell-hist-ignoredups t
            eshell-scroll-to-bottom-on-output t
            eshell-save-history-on-exit t
            eshell-list-files-after-cd t
            eshell-banner-message ""
            eshell-error-if-no-glob t
            eshell-visual-commands '("less" "ssh" "tmux" "top" "htop" "bash" "vim")
            eshell-visual-subcommands '(("git" "log" "df" "diff" "show"))
            eshell-term-name "eterm-color"))

    (t/eshell-init)


    (defun t/eshell-init-smart ()
      "Init smart eshell"
      (require 'em-smart)
      (setq eshell-where-to-jump 'begin
            eshell-review-quick-commands nil
            eshell-smart-space-goes-to-end t)
      (eshell-smart-initialize))

    (defun t/eshell-init-aliases ()
      (require 'em-alias)
      (dolist (alias (list
                      '("cleanupdsstore" "find . -name '*.DS_Store' -type f -ls -delete")
                      '("d" "dired $1")
                      '("e" "find-file $1")
                      '("f" "helm-find-files $1")
                      '("p" "helm-projectile")
                      '("emacs" "find-file $1")
                      '("emptytrash" "sudo rm -rfv /Volumes/*/.Trashes; rm -rfv ~/.Trash")
                      '("esudo" "find-file /sudo::/$1")
                      '("flushyosemitedns" "sudo discoveryutil mdnsflushcache;sudo discoveryutil udnsflushcaches")
                      '("gd" "magit-diff-unstaged")
                      '("gds" "magit-diff-staged")
                      '("grep" "grep --color=always $*")
                      '("gs" "magit-status")
                      '("gr" "cd ${git rev-parse --show-toplevel}")
                      '("gadd-origin-pr" "git config --add remote.origin.fetch \"+refs/pull/*/head:refs/remotes/origin/pr/*\"")
                      '("hidedesktop" "defaults write com.apple.finder CreateDesktop -bool false && killall Finder")
                      '("hidehidden" "defaults write com.apple.finder AppleShowAllFiles -boolean false && killall Finder")
                      '("ip" "dig +short myip.opendns.com @resolver1.opendns.com")
                      '("localip" "ipconfig getifaddr en0")
                      '("j" "z $*")
                      '("ll" "ls -laH $*")
                      '("l" "ls -H $*")
                      '("lout" "/System/Library/CoreServices/Menu\\ Extras/User.menu/Contents/Resources/CGSession -suspend")
                      '("md" "mkdir $1; cd $1")
                      ;;'("merge-pdfs" "gs -q -dNOPAUSE -dBATCH -sDEVICE=pdfwrite -sOutputFile=merged.pdf *.pdf")
                      '("serve" "http-server")
                      '("showdesktop" "defaults write com.apple.finder CreateDesktop -bool true && killall Finder")
                      '("showhidden" "defaults write com.apple.finder AppleShowAllFiles -boolean true && killall Finder")
                      '("essh" "cd \"/ssh:$1:~\"")
                      '("sudo" "*sudo $*")))
        (add-to-list 'eshell-command-aliases-list alias)))

    (defun t/eshell-buffer-id ()
      "Next eshell buffer id."
      (concat "*eshell: " (t/eshell-path-of-current-dir) "*"))

    (defun t/eshell-path-of-current-dir ()
      (file-name-directory (or (buffer-file-name) default-directory)))

    (defun t/eshell ()
      "Start, or switch to, `eshell' in the current working directory."
      (interactive)
      (let ((path (t/eshell-path-of-current-dir))
            (hasfile (not (eq (buffer-file-name) nil))))
        (eshell (t/eshell-buffer-id))
        (when (and hasfile (eq eshell-process-list nil))
          (goto-char (point-max))
          ;;(setenv "JAVA_HOME" (s-trim (shell-command-to-string "/usr/libexec/java_home -v 1.8")))
          (shell-command-to-string "jenv local 1.8")
          (setenv "BOOT_JVM_OPTIONS" "-Djdk.launcher.addmods=java.xml.bind")
          (setenv "PAGER" "cat"))))

    (defun t/eshell-clear ()
      "Clear the eshell buffer."
      (interactive)
      (let* ((inhibit-read-only t)
             (last (and (eolp) (eshell-get-old-input))))
        (erase-buffer)
        (eshell-reset)
        (when last
          (insert last))
        (evil-cp-append 1)))

    (defun t/eshell-quit-or-delete-char ()
      (interactive)
      (if (and (eolp)
               (looking-back eshell-prompt-regexp))
          (eshell-life-is-too-much)
        (delete-forward-char 1)))

    (t/add-hook-defun 'eshell-directory-change-hook t/hook-eshell-dir (rename-buffer (t/eshell-buffer-id) t))
    (t/add-hook-defun 'eshell-mode-hook t/hook-eshell
                      (paredit-mode 1)
                      (t/bind-in 'eshell-mode-map
                        "S-<return>" 'newline-and-indent
                        "C-l" 't/eshell-clear
                        "C-a" 'eshell-bol
                        "C-u" 'eshell-kill-input
                        ;; C-c c-d sends exit
                        "C-c C-u" 'universal-argument
                        )
                      (t/bind-in '(eshell-mode-map paredit-mode-map evil-insert-state-local-map)
                        "C-a" 'eshell-bol
                        "C-d" 't/eshell-quit-or-delete-char)
                      (t/bind-in '(evil-normal-state-local-map)
                        "C-a" 'eshell-bol)
                      (progn ;; helm for history
                        (setq eshell-cmpl-ignore-case t)
                        (eshell-cmpl-initialize)
                        (bind-key "C-r" 'helm-eshell-history evil-insert-state-local-map)
                        (define-key eshell-mode-map [remap eshell-pcomplete] 'helm-esh-pcomplete)
                        (define-key eshell-mode-map (kbd "M-P") 'helm-eshell-prompts-all)
                        (define-key eshell-mode-map (kbd "M-p") 'helm-eshell-history))
                      (progn
                        (defun t/eshell-kill-input--go-to-eol ()
                          "Go to end of line before killing input"
                          (end-of-line))
                        (advice-add 'eshell-kill-input :before #'t/eshell-kill-input--go-to-eol)))

    (progn
      ;; eshell prompt

      (defun curr-dir-git-branch-string (pwd)
        "Returns current git branch as a string, or the empty string if
PWD is not in a git repo (or the git command is not found)."
        (interactive)
        (when (and is-mac
                   (eshell-search-path "git")
                   (locate-dominating-file pwd ".git"))
          (let ((git-output (shell-command-to-string (concat "cd " (shell-quote-argument (expand-file-name pwd)) " && git branch | grep '\\*' | sed -e 's/^\\* //'"))))
            (if (> (length git-output) 0)
                (concat " " (substring git-output 0 -1))
              " (no branch)"))))

      (defun pwd-replace-home (pwd)
        "Replace home in PWD with tilde (~) character."
        (interactive)
        (let* ((home (expand-file-name (getenv "HOME")))
               (home-len (length home)))
          (if (and
               (>= (length pwd) home-len)
               (equal home (substring pwd 0 home-len)))
              (concat "~" (substring pwd home-len))
            pwd)))

      (defun pwd-shorten-dirs (pwd)
        "Shorten all directory names in PWD except the last two."
        (let ((p-lst (split-string pwd "/")))
          (if (> (length p-lst) 2)
              (concat
               (mapconcat (lambda (elm) (if (zerop (length elm)) ""
                                          (substring elm 0 1)))
                          (butlast p-lst 2)
                          "/")
               "/"
               (mapconcat (lambda (elm) elm)
                          (last p-lst 2)
                          "/"))
            pwd)))  ;; Otherwise, we just return the PWD

      (defun split-directory-prompt (directory short-dir)
        (if (string-match-p ".*/.*" short-dir)
            (list (file-name-directory short-dir)
                  (if (file-directory-p directory)
                      (file-name-nondirectory short-dir)
                    (file-name-base short-dir)))
          (list "" short-dir)))

      (defvar t-eshell-success-face 'doom-modeline-info)
      (defvar t-eshell-error-face 'doom-modeline-urgent)
      (setq eshell-prompt-function
            (lambda ()
              (let* ((pwd (eshell/pwd))
                     (directory (split-directory-prompt pwd (pwd-shorten-dirs (pwd-replace-home pwd))))
                     (parent (car directory))
                     (name (cadr directory))
                     (branch (or (curr-dir-git-branch-string (eshell/pwd)) ""))
                     (prompt (concat
                              (propertize parent 'face 'font-lock-builtin-face)
                              (propertize name 'face 'font-lock-constant-face)
                              (propertize branch 'face 'font-lock-comment-face)
                              (propertize " $" 'face (if (zerop eshell-last-command-status) t-eshell-success-face t-eshell-error-face))
                              (propertize " " 'face 'font-lock-preprocessor-face))))
                (t/propertize-read-only prompt)))))))

(progn
  ;; eshell git completion

  (defconst pcmpl-git-commands
    '("pr"
      "add" "bisect" "branch" "checkout" "clone"
      "commit" "diff" "fetch" "grep"
      "init" "log" "merge" "mv" "pull" "push" "rebase"
      "reset" "rm" "show" "status" "tag" )
    "List of `git' commands")

  (defun pcmpl-git-remotes ()
    "Return list of `git' remotes."
    (-drop-last 1 (s-split "\r?\n" (shell-command-to-string "git remote show"))))

  (defvar pcmpl-git-ref-list-cmd "git for-each-ref refs/ --format='%(refname)'"
    "The `git' command to run to get a list of refs")

  (defun pcmpl-git-get-refs (types)
    "Return a list of `git' refs filtered by TYPE."
    (with-temp-buffer
      (insert (shell-command-to-string pcmpl-git-ref-list-cmd))
      (goto-char (point-min))
      (let ((ref-list))
        (dolist (type types)
          (while (re-search-forward (concat "^refs/" type "/\\(.+\\)$") nil t)
            (add-to-list 'ref-list (match-string 1))))
        ref-list)))

  (require 'pcomplete)
  (defun pcomplete/git ()
    "Completion for `git'."

    (pcomplete-here* pcmpl-git-commands)
    (cond
     ;; complete files/dirs forever if the command is `add' or `rm'
     ((pcomplete-match (regexp-opt '("add" "rm")) 1)
      (while (pcomplete-here (pcomplete-entries))))
     ((pcomplete-match (regexp-opt '("pr")) 1)
      (while (pcomplete-here (append (pcmpl-git-get-refs '("heads")) (pcmpl-git-remotes)))))
     ;; provide branch completion for the command `checkout'.
     ((pcomplete-match "\\(co\\|checkout\\|merge\\|branch\\|diff\\)" 1)
      (pcomplete-here* (pcmpl-git-get-refs '("heads")))))))

(defun pcomplete/kill ()
  (while (pcomplete-match "^-" 'last) (pcomplete-here '("-1" "-2" "-3" "-6" "-9" "-14" "-15" "-l" "-s")))
  (while (and (pcomplete-match "" 'last)
              (pcomplete-match "-s" 'last -1)) (pcomplete-here '("HUP" "SIGHUP" "SIGINT" "SIGKILL" "SIGTERM" "SIGSTOP")))
  (while (pcomplete-here* (-map 's-trim (-> (shell-command-to-string "ps -eo pid | grep -v PID")
                                            (split-string "\n"))))))

;; pcomplete example
(defun pcomplete/torgeir ()
  (pcomplete-here* '("add" "remove"))
  (cond
   ((pcomplete-match "add" 1) (pcomplete-here* '("one" "two")))
   ((pcomplete-match "remove" 1) (pcomplete-here* '("two" "three")))))


(use-package pcmpl-git
  :commands eshell)

(use-package pcmpl-args
  :commands eshell
  :config
  (defun pcmpl-args-default-man-function (name)
    "torgeir: Patched to remove arguments to work on os x."
    (let ((process-environment process-environment))
      (push "MANWIDTH=10000" process-environment)
      (pcmpl-args-process-file "man" "--" name))))

(use-package pcmpl-homebrew
  :commands eshell)

(use-package pcomplete-extension
  :commands eshell)

;; make ret work on ls results
(eval-after-load "em-ls"
  '(progn
     (defun ted-eshell-ls-find-file-at-point (point)
       "RET on Eshell's `ls' output to open files."
       (interactive "d")
       (find-file (buffer-substring-no-properties
                   (previous-single-property-change point 'help-echo)
                   (next-single-property-change point 'help-echo))))

     (defun pat-eshell-ls-find-file-at-mouse-click (event)
       "Middle click on Eshell's `ls' output to open files.
 From Patrick Anderson via the wiki."
       (interactive "e")
       (ted-eshell-ls-find-file-at-point (posn-point (event-end event))))

     (let ((map (make-sparse-keymap)))
       (define-key map (kbd "RET")      'ted-eshell-ls-find-file-at-point)
       (define-key map (kbd "<return>") 'ted-eshell-ls-find-file-at-point)
       (define-key map (kbd "<mouse-2>") 'pat-eshell-ls-find-file-at-mouse-click)
       (defvar ted-eshell-ls-keymap map))

     (defadvice eshell-ls-decorated-name (after ted-electrify-ls activate)
       "Eshell's `ls' now lets you click or RET on file names to open them."
       (add-text-properties 0 (length ad-return-value)
                            (list 'help-echo "RET, mouse-2: visit this file"
                                  'mouse-face 'highlight
                                  'keymap ted-eshell-ls-keymap)
                            ad-return-value)
       ad-return-value)))

(provide 't-shell)
#+end_src
** Desktop

#+begin_src emacs-lisp :results silent
(defun t/desktop-project-name ()
  (when-let ((root (t/project-root)))
    (concat root
            ".desktop-"
            (car (-drop 1 (reverse (split-string root "/")))))))


(defun t/desktop-save ()
  (interactive)
  (if-let ((desktop-base-file-name (t/desktop-project-name)))
      (desktop-save (or desktop-dirname
                        (t/project-root)) t)
    (message "Not in a project.")))


(defun t/desktop-restore ()
  (interactive)
  (if-let (project-name (t/desktop-project-name))
      (if (file-exists-p (expand-file-name project-name))
          (when-let ((desktop-base-file-name project-name)
                     (desktop-dirname (expand-file-name user-emacs-directory)))
            (desktop-revert))
        (progn
          (dired ".")
          (t/desktop-save)))
    (message "Not in a project.")))
#+end_src

** Typography

Initial font and window transparency.

#+BEGIN_SRC emacs-lisp :results silent
(t/set-font (car t-fonts) t)
(t/transparency 100)
#+END_SRC

Highlight todos in all modes.

#+begin_src emacs-lisp :results silent
(use-package hl-todo
  :defer 1
  :config (global-hl-todo-mode))
#+END_SRC

Shorten ~function~ to ~f~. Can be handy for other annoying stuff as well.

#+BEGIN_SRC emacs-lisp :results silent
(t/add-hook-defun '(js2-mode-hook) t/ligatures
                  (push '("function" . ?ƒ) prettify-symbols-alist)
                  (prettify-symbols-mode))
#+END_SRC

No emojis in terminal (on os x at least).

#+BEGIN_SRC emacs-lisp :results silent
(progn
  (t/set-emoji-font nil) ; for when Emacs is started in GUI mode
  (t/add-hook 'after-make-frame-functions 't/set-emoji-font)) ; hook for when a frame is created with emacsclient

#+END_SRC
** Keys

#+BEGIN_SRC emacs-lisp :results silent
;; lisp-friendly
(setq hippie-expand-try-functions-list
      '(try-complete-file-name-partially
        try-complete-file-name
        try-expand-dabbrev-visible
        try-expand-dabbrev-all-buffers
        try-expand-dabbrev-from-kill
        try-expand-all-abbrevs
        try-complete-lisp-symbol-partially
        try-complete-lisp-symbol
        try-expand-list
        try-expand-line))

(comment
 (defun t/useful-buffer? (b)
   "Determine if a buffer is useful and you would like to jump to it."
   (let ((name (buffer-name b)))
     (and (not (get-buffer-window name nil)) ; not already visible in same frame
          (not (s-contains? "autoloads.el" name))
          (or (equal "*scratch*" name)
              (s-contains? "*eww" name)
              (s-contains? "*Org" name)
              (s-contains? "*eshell" name)
              (not (s-contains? "*" name))))))
 ;; skip non-useful buffers on next-buffer, prev-buffer, other-buffer
 (let ((entry-exists (assq 'buffer-predicate default-frame-alist)))
   (if entry-exists
       (setcdr entry-exists #'t/useful-buffer?)
     (push '(buffer-predicate . t/useful-buffer?) default-frame-alist))))


(t/bind-in 'minibuffer-local-map "C-w" 'backward-kill-word)
(t/bind-in 'global-map

  "s-k" 'previous-buffer
  "s-j" 'next-buffer

  "s->" 'next-multiframe-window
  "s-<" 'previous-multiframe-window

  "s-<left>" 't/smart-beginning-of-line
  "s-<right>" 'end-of-line

  "M-s-<up>" 'windmove-up
  "M-s-<right>" 'windmove-right
  "M-s-<down>" 'windmove-down
  "M-s-<left>" 'windmove-left

  "s-d" 't/split-window-right-and-move-there-dammit
  "s-D" 't/split-window-below-and-move-there-dammit

  ;; s-w quits like C-x C-w
  "s-w" #'t/delete-frame-or-hide-last-remaining-frame
  ;; TODO
  ;;"C-x C-c" #'t/delete-frame-or-hide-last-remaining-frame

  ;; buffer font size adjustment
  "s-?" (t/lambda (text-scale-increase 1))
  "s-_" (t/lambda (text-scale-decrease 1))
  "s-=" (t/lambda (text-scale-set 0))

  ;; global font size adjustment
  "s-+" 't/increase-font-size
  "s--" 't/decrease-font-size
  "s-0" 't/reset-font-size

  "<C-S-up>" 't/move-line-up
  "<C-S-down>" 't/move-line-down

  "M-p" 'backward-paragraph
  "M-n" 'forward-paragraph

  "C-c n" 't/cleanup-buffer-whitespace-and-indent
  "C-x C-k" 'kill-region

  "C-." 't/hippie-expand-no-case-fold
  "C-," 'company-complete
  "C-:" 't/hippie-expand-lines)
#+END_SRC

#+BEGIN_SRC emacs-lisp :results silent
(t/after re-builder (setq reb-re-syntax 'rx))
(t/add-hook 'text-mode-hook 'auto-fill-mode) ; wrap text in text modes
(t/add-hook 'text-mode-hook 'goto-address-prog-mode) ; navigate urls
(t/add-hook 'focus-out-hook #'garbage-collect) ; make it feel snappier
(t/add-hook 'before-save-hook #'delete-trailing-whitespace nil t)
(t/add-hook 'find-file 't/find-file-check-make-large-file-read-only-hook)
(setq large-file-warning-threshold (* 20 ; mb
                                      1024 1024))

(t/after cider-overlays
  ;; inline evaled results when in elisp using cider
  (autoload 'cider--make-result-overlay "cider-overlays")
  (defun endless/eval-overlay (value point)
    (cider--make-result-overlay (format "%S" value) :where point :duration 'command) value) ; preserve the return value
  (advice-add 'eval-region :around (lambda (f beg end &rest r) (endless/eval-overlay (apply f beg end r) end)))
  (advice-add 'eval-last-sexp :filter-return (lambda (r) (endless/eval-overlay r (point))))
  (advice-add 'eval-defun :filter-return (lambda (r) (endless/eval-overlay r (save-excursion (end-of-defun) (point))))))

(evil-leader/set-key "'" 't/eshell)
(evil-leader/set-key "<" 't/eshell)
(evil-leader/set-key "|" 't/eshell)

(evil-leader/set-key "TAB" 't/switch-to-previous-buffer)
(evil-leader/set-key "u" 'universal-argument)

(defvar t-regex-mode nil "reb-mode on or not")
(defun t/toggle-regex-mode ()
  (interactive)
  (if t-regex-mode (reb-quit) (re-builder))
  (setq t-regex-mode (not t-regex-mode)))

(t/add-hook 'ediff-keymap-setup-hook
            (t/lambda (define-key ediff-mode-map "d" 't/ediff-use-both)))

(t/declare-prefix "a" "Applications"
                  "B" 'w3m
                  "c" 'calendar
                  "b" #'t/browse-url-at-point
                  "C" 'calc-dispatch
                  "d" 'md4rd
                  "g" 'gnus
                  "h" 't/hackernews
                  "i" 't/open-in-intellij
                  "p" 'proced
                  "m" 'popwin:messages
                  "M" (t/lambda nil (switch-to-buffer "*Messages*") (end-of-buffer))
                  "n" (t/lambda (t/eww-readable "https://www.nrk.no/nyheter/" 't/clean-nrk-buffer))
                  "R" #'t/toggle-regex-mode
                  "se" 't/eshell
                  "st" 'ansi-term
                  "sT" 'term
                  "ss" 'shell
                  "S" 'suggest
                  "w" 'eww
                  "W" (t/lambda nil
                        (t/eww-readable "https://en.wikipedia.org/wiki/Special:Random")
                        (visual-line-mode -1)
                        (visual-line-mode 1)))

(t/declare-prefix "fe" "Editor")

(t/declare-prefix "fe" "Files"
                  "R" 't/config-reload
                  "i" 't/helm-files-emacs-init-files)

(t/declare-prefix "fep" "Packages"
                  "i" 'package-install
                  "r" 'package-refresh-contents
                  "l" 'paradox-list-packages
                  "R" 'package-reinstall
                  "U" 't/upgrade-packages)

(t/declare-prefix "t" "Toggle"
                  "D" 'toggle-debug-on-error
                  "f" 't/cycle-font
                  "dd" 'darkroom-mode
                  "dt" 'darkroom-tentative-mode
                  "F" 'toggle-frame-fullscreen
                  "t" 't/load-theme-cycle
                  "T" 't/transparency
                  "m" 'imenu-list-smart-toggle
                  "M" 'menu-bar-mode
                  "n" #'t/toggle-line-numbers
                  "r" 'nlinum-relative-toggle
                  "L" 'hl-line-mode
                  "l" 'visual-line-mode
                  "." 'whitespace-mode
                  "W" 'global-writeroom-mode
                  "w" 'writeroom-mode
                  "Cc" 'rainbow-mode
                  "Cd" 'rainbow-delimiters-mode)

(t/declare-prefix "b" "Buffers"
                  "S" 'save-some-buffers
                  "s" 't/switch-to-scratch-buffer
                  "d" 'kill-this-buffer
                  "t" 't/kill-other-buffers
                  "b" 'ivy-switch-buffer
                  "o" 't/switch-to-previous-buffer
                  "p" 'popwin:display-buffer
                  "n" 'next-buffer
                  "R" 'revert-buffer)

(t/declare-prefix "d" "Doc/Desktop"
                  "d" 'dash-at-point
                  "S" 'dash-at-point-with-docset
                  "s" #'t/desktop-save
                  "r" #'t/desktop-restore
                  "c" 'desktop-clear)

(t/declare-prefix "x" "Text manipulation"
                  "a" 'align-regexp
                  "k" 'ido-kill-buffer
                  "m"  'counsel-M-x
                  "x" 'smex-major-mode-commands
                  "ls" 't/sort-lines
                  "lu" 't/uniquify-lines)

(t/declare-prefix "xt" "Transpose"
                  "c" 'transpose-chars
                  "w" 'transpose-words
                  "l" 'transpose-lines
                  "f" 'transpose-frame
                  "s" 'transpose-sexps
                  "S" 'transpose-sentences
                  "p" 'transpose-paragraphs)

(t/declare-prefix "r" "Registers"
                  "r" 'evil-show-registers)

(t/declare-prefix "f" "Files/Frame"
                  "b" 'ivy-switch-buffer
                  "f" 'counsel-find-file
                  "l" 't/neotree-open-file
                  "L" 'neotree-hide
                  "j" 'dired-jump
                  "J" 'dired-jump-other-window
                  "d" 'delete-frame
                  "g" 'ffap
                  "o" 't/open-in-desktop
                  "r" 'counsel-recentf)

(t/declare-prefix "h" "Help"
                  "h" #'t/describe
                  "f" #'t/face-at-point
                  "F" 'counsel-faces
                  "C" 'counsel-colors-emacs
                  "a" 'counsel-apropos
                  "l" 'counsel-find-library
                  "i" 'counsel-info-lookup-symbol
                  ;; "I" 'helm-info
                  "r" 'ivy-resume
                  ;;"Db" 'ivy-descbinds
                  "dd" 'dash-at-point
                  "df" 'counsel-describe-function
                  "dF" 'counsel-describe-face
                  "dk" 'describe-key-briefly
                  "dK" 'describe-key
                  "dc" 'describe-char
                  "dm" 'describe-mode
                  "dM" 'describe-minor-mode
                  "ds" 'counsel-describe-symbol
                  "dt" 'describe-theme
                  "dp" 'describe-package
                  "dv" 'counsel-describe-variable)

(t/declare-prefix "e" "Errors"
                  "c" 'flycheck-clear
                  "p" 'flycheck-previous-error
                  "n" 'flycheck-next-error
                  "N" 'flycheck-previous-error
                  "l" 'flycheck-list-errors
                  "v" 'flycheck-verify-setup
                  "t" 'flycheck-mode)

(t/declare-prefix "w" "Windows"
                  "h" 'windmove-left
                  "j" 'windmove-down
                  "k" 'windmove-up
                  "l" 'windmove-right
                  "n" 'make-frame-command
                  "D" 't/delete-frame-or-hide-last-remaining-frame
                  "d" 'delete-window
                  "t" 'delete-other-windows
                  "o" 't/previous-window
                  "=" 'balance-windows-area
                  "-" 'evil-window-decrease-width
                  "+" 'evil-window-increase-width
                  "u" 'winner-undo
                  "R" 'winner-redo
                  "r" 'transpose-frame)

(t/declare-prefix "z" "Folding"
                  "z" 'hs-toggle-hiding
                  "f" 'hs-hide-block
                  "F" 'hs-hide-all
                  "r" 'hs-show-block
                  "R" 'hs-show-all)

(t/declare-prefix "j" "Jump to"
                  "f" 'find-function
                  "k" 'find-function-on-key
                  "p" (lambda (key)
                        (interactive "kPress keybinding to run in popup: ")
                        (popwin:display-buffer-1 (popwin:dummy-buffer))
                        (let ((keys (key-binding key)))
                          (funcall
                           (cond ((stringp keys) (symbol-function keys))
                                 (t keys)))))
                  "w" 'ace-window
                  "j" 'avy-goto-char-timer
                  "t" 'avy-goto-char-timer
                  "c" 'avy-goto-char
                  "C" 'avy-goto-char-2
                  "l" 'avy-goto-line
                  "L" 'avy-goto-char-in-line
                  "W" 'avy-goto-word-1)

(t/declare-prefix "ja" "Jump to above"
                  "l" 'avy-goto-line-above
                  "W" 'avy-goto-word-0-above
                  "w" 'avy-goto-word-1-above
                  "c" 'avy-goto-char-2-above
                  "s" 'avy-goto-symbol-1-above)

(t/declare-prefix "jb" "Jump to below"
                  "l" 'avy-goto-line-below
                  "w" 'avy-goto-word-1-below
                  "W" 'avy-goto-word-0-below
                  "c" 'avy-goto-char-2-below
                  "s" 'avy-goto-symbol-1-below)

(t/declare-prefix "h" "Highlight"

                  "H" (t/lambda (highlight-symbol (thing-at-point 'symbol)))
                  "n" 'highlight-symbol-next
                  "N" 'highlight-symbol-prev)

(t/declare-prefix "p" "Project"
                  "a" 'counsel-projectile-org-agenda
                  "b" 'counsel-projectile-switch-to-buffer
                  "c" 'counsel-projectile-switch-project
                  "d" 't/projectile-dired
                  "w" 't/projectile-desktop
                  "f" 'counsel-projectile-find-file
                  "F" 'counsel-projectile-find-file-dwim
                  "g" 't/projectile-magit-status
                  "G" 'projectile-regenerate-tags
                  "k" 'projectile-kill-buffers
                  "l" 't/neotree-open-file
                  "L" 'neotree-hide
                  "o" 't/open-in-desktop
                  "p" 't/projectile-visit-git-link-pulls
                  "r" 't/projectile-rg
                  "s" 't/projectile-ag
                  "R" 'projectile-replace
                  "S" 'projectile-save-project-buffers
                  "t" 'projectile-find-test-file)

(t/declare-prefix "s" "Search"
                  "I" 'counsel-semantic-or-imenu
                  "b" 'ivy-switch-buffer
                  "f" 'counsel-rg
                  "g" 'counsel-web-thing-at-point
                  "G" 'counsel-web-search
                  "m" 'counsel-imenu
                  "i" 'lsp-find-implementation
                  "r" 'lsp-find-references
                  "d" 'lsp-find-definition
                  "D" 'lsp-find-declaration
                  "a" 'counsel-projectile-ag
                  "p" 'counsel-projectile-rg
                  "s" 'swiper
                  "t" 'etags-select-find-tag-at-point
                  ;;"w" 'helm-wikipedia-suggest
                  )
#+END_SRC
** Frame and Window

*** Transpose frame

Switch around split frame rotation.

#+BEGIN_SRC emacs-lisp :results silent
(use-package transpose-frame :commands transpose-frame)
#+END_SRC
*** Window history

Revert to previous window configurations

#+BEGIN_SRC emacs-lisp :results silent
(use-package winner
  :ensure nil
  :straight nil
  :commands (winner-undo winner-redo)
  :config (winner-mode))
#+END_SRC

*** Margins

Breathing room nice.

#+BEGIN_SRC emacs-lisp :results silent
(t/margins-global 1)
#+END_SRC

*** Frame size

Change frame width and height consistently across os'es.

#+begin_src emacs-lisp :results silent
(bind-keys
 :map
 global-map
 ("<C-s-left>" . t/decrease-frame-width)
 ("<C-s-right>" . t/increase-frame-width)
 ("<C-s-down>" . t/increase-frame-height)
 ("<C-s-up>" . t/decrease-frame-height))
#+end_src

*** Frame movement

Move window consistently across os'es.

#+begin_src emacs-lisp :results silent
(bind-keys
 :map
 global-map
 ("<C-S-s-left>" . t/move-frame-left)
 ("<C-S-s-right>" . t/move-frame-right)
 ("<C-S-s-down>" . t/move-frame-down)
 ("<C-S-s-up>" . t/move-frame-up))
#+end_src

** Server

#+BEGIN_SRC emacs-lisp :results silent
  (unless (fboundp 'server-running-p) (require 'server))
  (unless (server-running-p) (server-mode))
  (t/add-hook 'server-visit-hook 'server-remove-kill-buffer-hook)
#+END_SRC

** Org
*** Src code blocks

Full size editing, and colors also when in plain .org files, not only when
editing src blocks.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-src-window-setup 'current-window ; edit code src blocks in current window
      org-src-fontify-natively t
      org-src-tab-acts-natively t
      org-confirm-babel-evaluate nil ; don't prompt on every code run
      org-export-babel-evaluate nil ; don't run stuff automatically on export
      org-edit-src-content-indentation 0)
#+END_SRC

Confirming and exiting src code blocks is much faster like this.

#+BEGIN_SRC emacs-lisp :results silent
(bind-key "\C-c\C-c" 'org-edit-src-exit 'org-src-mode-map)
#+END_SRC

*** Folders with .org files

#+BEGIN_SRC emacs-lisp :results silent
(defun t/org-directory (path) (concat org-directory "/" path))
(setq org-directory (t/user-dropbox-folder "org"))
#+END_SRC

*** Archiving

Handy function to clear out all completed tasks in file.

#+BEGIN_SRC emacs-lisp :results silent
(defun t/org-archive-done-tasks ()
  (interactive)
  (org-map-entries (lambda ()
                     (org-archive-subtree)
                     (setq org-map-continue-from (outline-previous-heading)))
                   "/DONE" 'file)
  (org-map-entries (lambda ()
                     (org-archive-subtree)
                     (setq org-map-continue-from (outline-previous-heading)))
                   "/CANCELLED" 'file))
#+END_SRC

*** Config

General org config, didn't bother sorting it.

#+BEGIN_SRC emacs-lisp :results silent
(setq
 ;; org-ellipsis " >" ; the ... is ok
 org-startup-indented t ; turn on org-indent-mode
 org-return-follows-link t
 org-tab-follows-link nil
 org-support-shift-select t ; shift can be used to mark multiple lines
 org-hide-leading-stars t
 org-hide-emphasis-markers nil
 org-loop-over-headlines-in-active-region 'start-level ; org-archive with friends work on multiple items
 org-blank-before-new-entry '((heading . auto) (plain-list-item . t)) ; newlines
 org-cycle-separator-lines 2 ; number of empty lines after heading needed to show visible newline between headings
 org-catch-invisible-edits 'show ; show invisibles on edit
 org-enforce-todo-dependencies t ; block parent TODOs if child is not completed
 org-refile-targets '((nil :maxlevel . 2)
                      (org-agenda-files :maxlevel . 2))
 org-refile-use-outline-path 'file ; enable refile to top level in file too
 org-outline-path-complete-in-steps nil ; refile to subpaths
 org-tags-column -60           ; tag position after headings
 org-export-coding-system 'utf-8
 org-default-notes-file (t/org-directory "home.org")
 org-special-ctrl-k t         ; don't clear tags, etc
 org-adapt-indentation t      ; move text to align with heading bullets

 ;; doom theme
 org-fontify-whole-heading-line t
 org-fontify-done-headline t
 org-fontify-quote-and-verse-blocks t
 org-fontify-emphasized-text t

 org-reverse-note-order t      ; newest notes first
 org-log-done 'time            ; log when todos are completed
 org-log-redeadline 'time      ; log when deadline changes
 org-log-reschedule 'time      ; log when schedule changes
 org-use-fast-todo-selection t
 org-todo-keywords '((sequence "TODO(t)" "STARTED(s)" "|" "DONE(d)" "CANCELLED(c)")))
#+END_SRC

*** Export

Clean export stamp.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-html-postamble t
      org-html-postamble-format
      '(("en" "<p class=\"author\">%a (%e)</p>\n<p class=\"date\">%T</p>")))
#+END_SRC

*** Capture

#+BEGIN_SRC emacs-lisp :results silent
(defun t/org-capture-chrome-link-template (&optional &rest args)
  (concat "* TODO %? :url:%^G\n\n" (t/grab-chrome-url)))

(defun t/org-capture-elfeed-link-template (&optional &rest args)
  (concat "* TODO %? :url:%^G\n\n%i\n" (elfeed-entry-link elfeed-show-entry)))

(setq org-capture-templates
      `(("t" "Task" entry (file+olp org-default-notes-file "Home" "Tasks") "* TODO %? %^G\n\n%i\n\n" :prepend t)
        ("s" "Saga" entry (file+olp ,(t/org-directory "bekk/saga.org") "Saga" "Tasks") "* TODO %? \n\n%i\n\n" :prepend t)
        ("d" "Shared calendar event" entry (file ,(t/org-directory "gcal/delt.org")) "* %?\n")
        ("f" "File location" entry (file+olp org-default-notes-file "Home" "Tasks") "* TODO %? %^G\n\n%i%a\n\n")
        ("e" "Elfeed location" entry (file+olp org-default-notes-file "Home" "Tasks") (function t/org-capture-elfeed-link-template))
        ("c" "Chrome location" entry (file+olp org-default-notes-file "Home" "Tasks") (function t/org-capture-chrome-link-template))))
#+END_SRC
*** org-goto

Make org-goto play nice with counsel.

#+begin_src elisp-mode :results silent
(setq org-goto-interface 'outline-path-completion)
(setq org-outline-path-complete-in-steps nil)
#+end_src

*** Initialize

#+BEGIN_SRC emacs-lisp :results silent
(use-package org
  :straight org-plus-contrib
  :config
  (t/after org-agenda
    (bind-key "s-s" 'org-save-all-org-buffers org-agenda-mode-map)
    (unbind-key "C-," org-mode-map)) ;; don't need to cycle agenda files

  (evil-add-command-properties #'outline-up-heading :jump t)
  (evil-add-command-properties #'outline-next-heading :jump t)
  (evil-add-command-properties #'outline-previous-heading :jump t)
  (evil-add-command-properties #'org-previous-visible-heading :jump t)
  (evil-add-command-properties #'org-next-visible-heading :jump t))

#+END_SRC

*** Keybindings

#+BEGIN_SRC emacs-lisp :results silent
(t/declare-prefix "o" "Org"
                  "c" 'org-capture
                  "e" 'org-export-dispatch
                  "g" 'org-mac-grab-link
                  "a" 'org-agenda
                  "A" 't/org-archive-done-tasks
                  "n" 'org-alert-check
                  "hi" 'org-info)

(t/declare-prefix "ol" "Links"
                  "s" 'org-store-link
                  "i" 'org-insert-link)

(t/declare-prefix "ot" "Tags"
                  "a" 'org-archive-set-tag
                  "t" 'org-set-tags-command)

(t/declare-prefix "oT" "Table"
                  "Tg" 'org-table-toggle-coordinate-overlays
                  "Tf" 'org-table-formula)

(t/declare-prefix "oC" "Clock"
                  "r" 'org-clock-report
                  "i" 'org-clock-in
                  "o" 'org-clock-out)
#+END_SRC

*** Autocomplete

Fix disappearing company.

#+BEGIN_SRC emacs-lisp :results silent
(t/after company
  (t/add-company-backends-hook 'org-mode-hook 'company-capf))
(t/add-hook-defun 'org-mode-hook t/hook-add-pcomplete-to-capf
                  (t/add-hook 'completion-at-point-functions 'pcomplete-completions-at-point nil t))
#+END_SRC

*** Hook

#+BEGIN_SRC emacs-lisp :results silent
(t/add-hook 'org-babel-after-execute-hook 't/org-fix-inline-images)

(t/add-hook-defun 'org-mode-hook t/hook-org
                  ;; bring back stolen smartparen keys
                  (t/bind-in '(evil-motion-state-local-map)
                    "M-<up>" 'org-metaup
                    "M-<down>" 'org-metadown
                    "M-S-<right>" 'org-shiftmetaright
                    "M-S-<left>" 'org-shiftmetaleft)
                  (evil-snipe-override-local-mode)
                  (org-display-inline-images t t)
                  (visual-line-mode 1))
#+END_SRC

*** Babel

Modules to evaluate.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-modules '(org-tempo ; templates
                    org-mouse))
(org-load-modules-maybe t)

;;(require 'ox-md)
(require 'ox-gfm)
(require 'ob-clojure)
(use-package ob-restclient)

(setq org-babel-clojure-backend 'cider)

(org-babel-do-load-languages
 'org-babel-load-languages
 '(;;(elasticsearch . t)
   (emacs-lisp . t)
   (clojure . t)
   (dot . t)
   (gnuplot . t)
   (js . t)
   (latex . t)
   (python . t)
   (restclient . t)
   (ruby . t)
   (shell . t)))
#+END_SRC

Fix js eval https://emacs.stackexchange.com/questions/55690/org-babel-javascript-error.

#+BEGIN_SRC emacs-lisp :results silent
(setq org-babel-js-function-wrapper
      "console.log(require('util').inspect(function(){\n%s\n}(), { depth: 100 }))")
#+END_SRC

*** Agenda

#+BEGIN_SRC emacs-lisp :results silent
(defun t/org-skip-subtree-if-priority (priority)
  "Skip an agenda subtree if it has a priority of PRIORITY.

PRIORITY may be one of the characters ?A, ?B, or ?C."
  (let ((subtree-end (save-excursion (org-end-of-subtree t)))
        (pri-value (* 1000 (- org-lowest-priority priority)))
        (pri-current (org-get-priority (thing-at-point 'line t))))
    (if (= pri-value pri-current)
        subtree-end
      nil)))


(defun t/org-agenda-todo-type (name)
  `((org-agenda-remove-tags t)
    (org-agenda-sorting-strategy '(tag-up priority-down))
    (org-agenda-todo-keyword-format "")
    (org-agenda-overriding-header ,name)))


(defun t/org-agenda-pri-a (&rest tags)
  (string-join (-map (lambda (tag) (format "%s+PRIORITY=\"A\"" tag)) tags) "|"))

(defun t/org-agenda-pri (header &rest tags)
  (list (apply 't/org-agenda-pri-a tags)
        `((org-agenda-skip-function '(org-agenda-skip-entry-if 'todo 'done))
          (org-agenda-overriding-header ,header))))

(defun t/org-agenda-day (tags)
  (list tags '((org-agenda-span 'day)
               (org-agenda-ndays-to-span 1)
               (org-agenda-time-grid nil))))

(defun t/org-agenda-not-pri (header tags skip)
  (list tags `((org-agenda-overriding-header ,header)
               (org-agenda-skip-function '(or (t/org-skip-subtree-if-priority ?A)
                                              (org-agenda-skip-if nil (quote ,skip)))))))

(defun t/org-agenda-todos (header tags)
  (t/org-agenda-not-pri header tags '(scheduled deadline)))

(defun t/org-agenda-todos-scheduled (header tags)
  (t/org-agenda-not-pri header tags '(notscheduled deadline)))

(defun t/org-day-summary (&rest tags)
  `((tags ,@(apply 't/org-agenda-pri (append (list "Pri") tags)))
    (agenda ,@(t/org-agenda-day (string-join tags "|")))
    (tags-todo ,@(t/org-agenda-todos "Todo" (string-join tags "|")))
    (tags-todo ,@(t/org-agenda-todos-scheduled "Scheduled todo" (string-join tags "|")))))

(defun t/org-agenda-read ()
  '(tags-todo "book|read|twitter|pocket" ((org-agenda-overriding-header "Read"))))

(setq org-agenda-include-diary t
      org-agenda-diary-file (t/org-directory "diary.org")
      org-agenda-default-appointment-duration nil
      org-agenda-window-setup 'current-window;;'only-window ; delete other windows when showing agenda
      org-agenda-restore-windows-after-quit t ; restore them again
      org-agenda-files (t/find-org-files-recursively org-directory "org$\\\|txt$") ; where to look for org files
      org-agenda-text-search-extra-files (t/find-org-files-recursively (t/user-file "Dropbox/org") "org_archive$")
      org-agenda-skip-scheduled-if-done nil ; prevent showing done scheduled items
      org-agenda-custom-commands `(("T" alltodo)
                                   ("C" todo "DONE" ,(t/org-agenda-todo-type "DONE"))
                                   ("t" todo "TODO" ,(t/org-agenda-todo-type "TODO"))
                                   ("b" todo "STARTED" ,(t/org-agenda-todo-type "STARTED"))
                                   ("c" todo "CANCELLED" ,(t/org-agenda-todo-type "CANCELLED"))
                                   ("m" tags-todo "serie|film")
                                   ("e" tags-todo "emacs")
                                   ("r" tags-todo "book|read|twitter|pocket")
                                   ("v" tags-todo "video")
                                   ("w" "work" ,(append (t/org-day-summary "+bekk-home" "+saga-home")
                                                        `((tags "+someday+saga")
                                                          (tags "+someday+bekk"))))
                                   ("h" "home" ,(append (list (t/org-agenda-read))
                                                        (t/org-day-summary "+home-emacs-someday")
                                                        `((tags-todo "+someday-work" ((org-agenda-overriding-header "Someday"))))))))
#+END_SRC

**** Weather

Show weather in agenda with ~%%(org-weather-metno)~

#+BEGIN_SRC emacs-lisp :results silent
(use-package weather-metno
  :after org
  :config
  (progn
    (setq weather-metno-location-name "Trondheim, Norway"
          weather-metno-location-latitude lat-trh
          weather-metno-location-longitude lon-trh)))
#+END_SRC

**** Moons

Show moons in agenda ~%%(t/org-lunar-phases)~.

#+BEGIN_SRC emacs-lisp :results silent
(with-no-warnings (defvar date))
(defun t/org-lunar-phases ()
  "Show lunar phase in Agenda buffer."
  (require 'lunar)
  (let* ((phase-list (lunar-phase-list (nth 0 date) (nth 2 date)))
         (phase (cl-find-if (lambda (phase) (equal (car phase) date))
                            phase-list)))
    (when phase
      (setq ret (concat (lunar-phase-name (nth 2 phase)) " "
                        (substring (nth 1 phase) 0 5))))))

(defadvice lunar-phase-name (around sv-lunar-phase-name activate)
  "Månefasenavn på norsk."
  (setq ad-return-value
        (let ((phase (ad-get-arg 0)))
          (cond ((= 0 phase) "Nymåne ●")
                ((= 1 phase) "Månen i ny ☽")
                ((= 2 phase) "Fullmåne ○")
                ((= 3 phase) "Månen i ne ☾")))))
#+END_SRC

*** Tags

Realign all tags on save.

#+BEGIN_SRC emacs-lisp :results silent
(defun t/org-mode-realign-all-tags ()
  "Code to realign tags, stolen from org.el"
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward org-outline-regexp-bol nil t)
      (org-set-tags (org-get-tags nil t))
      (org-set-tags (seq-remove (lambda (tag)
                                  (get-text-property 0 'inherited tag))
                                (org-get-tags)))
      (end-of-line))))

(t/add-hook-defun 'before-save-hook t/org-mode-before-save
                  (when (eq major-mode 'org-mode)
                    (t/org-mode-realign-all-tags)))
#+END_SRC

*** Movement

Reselect visual when moving multiple lines.

#+BEGIN_SRC emacs-lisp :results silent
(setq t-org-move-tree-was-visual nil)
(defun t/org-visual-restore ()
  (when t-org-move-tree-was-visual
    (evil-normal-state)
    (evil-visual-restore)
    (setq t-org-move-tree-was-visual nil)))
(defadvice org-metaup   (before t/before-org-metaup activate) (setq t-org-move-tree-was-visual (region-active-p)))
(defadvice org-metadown (before t/before-org-metadown activate) (setq t-org-move-tree-was-visual (region-active-p)))
(defadvice org-metaup   (after t/after-org-metaup activate) (t/org-visual-restore))
(defadvice org-metadown (after t/after-org-metadown activate) (t/org-visual-restore))
#+END_SRC

*** Refile

Save org mode buffers after refile.

#+BEGIN_SRC emacs-lisp :results silent
(defadvice org-refile (after t/after-org-refile activate)
  (org-save-all-org-buffers))
#+END_SRC

*** Timers

#+BEGIN_SRC emacs-lisp :results silent
(defun t/jump-to-org-agenda ()
  (interactive)
  (let ((agenda-buffer (get-buffer "*Org Agenda*"))
        wind)
    (if (and (not (equal agenda-buffer (current-buffer)))
             agenda-buffer)
        (if (setq wind (get-buffer-window agenda-buffer))
            (select-window wind)
          (if (called-interactively-p)
              (progn
                (select-window (display-buffer agenda-buffer t t))
                (org-fit-window-to-buffer))
            (with-selected-window (display-buffer agenda-buffer)
              (org-fit-window-to-buffer))))
      (call-interactively 'org-agenda-list))))

(defvar t-org-file-save-since-last-idle nil)
;; Hook to remember if org files are saved since last idle timer.
(t/add-hook-defun 'before-save-hook t/org-mode-before-save-since-last-idle
                  (when (eq major-mode 'org-mode)
                    (setq t-org-file-save-since-last-idle t)))

(defun t/org-idle-timer ()
  "Timer to run when idle for syncing org."
  (interactive)
  (when t-org-file-save-since-last-idle
    (message "Syncing agenda...")
    (org-save-all-org-buffers)
    (comment (t/org-export-calendars))
    (setq t-org-file-save-since-last-idle nil)
    (message "Syncing agenda... done")))

(defun t/org-export-calendars ()
  "Export given set of calendars to ical files, so you can subscribe to their dropbox links in ical.
Locally redefines org-agenda-files not to export all agenda files."
  (interactive)
  (let ((org-agenda-files (cons org-default-notes-file
                                (mapcar #'t/org-directory
                                        '("home.org"
                                          "bekk/bekk.org"
                                          "bekk/saga.org"
                                          "bekk/datainn.org")))))
    (org-icalendar-export-agenda-files)))

(when (not is-ms)
  (t/idle-timer t-timers-sync-org-idle #'t/org-idle-timer 5)
  (t/idle-timer t-timers-sync-org-gcal 'org-gcal-fetch 30))
#+END_SRC

*** Tables

#+BEGIN_SRC emacs-lisp :results silent
(when (boundp 'org-evil-table-mode-map)
  (t/bind-in 'org-evil-table-mode-map
    "M-S-<left>" 'org-table-delete-column
    "M-S-<right>" 'org-table-insert-column))
#+END_SRC

*** Bullets

Blank line before new entries with text, but not headings following other headings (todolists).

#+BEGIN_SRC emacs-lisp :results silent
(setq org-blank-before-new-entry
      '((heading . always)
        (plain-list-item . nil)))

(defun t/call-rebinding-org-blank-behaviour (fn)
  (let ((org-blank-before-new-entry
         (copy-tree org-blank-before-new-entry)))
    (when (org-at-heading-p)
      (rplacd (assoc 'heading org-blank-before-new-entry) nil))
    (call-interactively fn)))

(defun t/org-meta-return-dwim ()
  (interactive)
  (if (looking-back "^")
      (call-interactively 'org-meta-return)
    (progn
      (evil-append-line 0)
      (t/call-rebinding-org-blank-behaviour 'org-meta-return))))

(defun t/org-insert-todo-heading-dwim ()
  (interactive)
  (t/call-rebinding-org-blank-behaviour 'org-insert-todo-heading)
  (evil-cp-append 1))

(defun t/org-insert-heading-respect-content-dwim ()
  (interactive)
  (t/call-rebinding-org-blank-behaviour 'org-insert-heading-respect-content)
  (evil-cp-append 1))

(defun t/org-insert-todo-heading-respect-content-dwim ()
  (interactive)
  (t/call-rebinding-org-blank-behaviour 'org-insert-todo-heading-respect-content)
  (evil-cp-append 1))

(t/add-hook-defun 'org-mode-hook t/hook-org-meta
                  (t/bind-in 'org-mode-map
                    "<return>" 'org-return
                    "C-w" 'org-refile
                    "M-<return>" 't/org-meta-return-dwim
                    "M-S-<return>" 't/org-insert-todo-heading-dwim
                    "C-<return>" 't/org-insert-heading-respect-content-dwim
                    "C-S-<return>" 't/org-insert-todo-heading-respect-content-dwim))

#+END_SRC

*** Yasnippet

#+BEGIN_SRC emacs-lisp :results silent
;; yas in org
(defun yas/org-very-safe-expand ()
  (let ((yas/fallback-behavior 'return-nil)) (yas-expand)))

(defun yas/org-setup ()
  (make-variable-buffer-local 'yas-trigger-key)
  (setq yas-trigger-key [tab])
  (add-to-list 'org-tab-first-hook 'yas/org-very-safe-expand)
  (define-key yas-keymap [tab] 'yas-next-field))

;; See https://github.com/eschulte/emacs24-starter-kit/issues/80.
(setq org-src-tab-acts-natively nil)

(t/after yasnippet ;; TODO
  (t/add-hook 'org-mode-hook #'yas/org-setup))

#+END_SRC

*** Fonts

Equal size fonts. Remove subsequent leading bullets.

#+BEGIN_SRC emacs-lisp :results silent
(t/add-hook-defun 'org-mode-hook t/reset-org-font-sizes
                  (dolist (face '(org-level-1
                                  org-level-2
                                  org-level-3
                                  org-level-4
                                  org-level-5))
                    (set-face-attribute face nil :weight 'semi-bold :height 1.0)))
(t/add-hook-defun 'org-mode-hook t/remove-org-mode-stars
                  (set-face-attribute 'org-hide nil :foreground (face-attribute 'default :background)))

#+END_SRC

*** Alerts

#+BEGIN_SRC emacs-lisp :results silent
(use-package org-alert
  :if nil
  :commands t/org-idle-timer
  :config
  (progn
    (setq alert-default-style 'osx-notifier
          org-alert-interval (* 1 60 60))
    (org-alert-enable)))

#+END_SRC

*** Links

Fetch stuff easiliy, e.g. urls from Chrome, urls to emails from Mail etc.

#+BEGIN_SRC emacs-lisp :results silent
(use-package org-mac-link
  :straight org-plus-contrib
  :load-path "lisp/org-mode/contrib/lisp"
  :commands (org-mac-grab-link
             org-mac-chrome-get-frontmost-url))

#+END_SRC
** Spray mode

Always had plans to read faster with this one..

#+BEGIN_SRC emacs-lisp :results silent
(use-package spray
  :commands spray-mode
  :init
  (progn
    (setq spray-wpm 680
          spray-height 170
          spray-margin-top 0
          spray-margin-left 0)
    (t/declare-prefix "t" "Toggle"
                      "s" (t/micro-state-in-mode
                           'spray-mode
                           "s" 'spray-slower
                           "f" 'spray-faster
                           "SPC" 'spray-start/stop
                           "<left>" 'spray-backward-word
                           "<right>" 'spray-forward-word))
    (t/add-hook-defun 'spray-mode-hook t/hook-spray
                      (setq-local spray-margin-top (truncate (/ (window-height) 2.7)))
                      (setq-local spray-margin-left (truncate (/ (window-width) 2.7)))
                      (beacon-mode -1)
                      (t/locally-disable-cursor)
                      (set-face-foreground 'spray-accent-face
                                           (face-foreground 'font-lock-keyword-face)))))


#+END_SRC

** Twitter

#+BEGIN_SRC emacs-lisp :results silent
(use-package twittering-mode
  :commands twittering-mode
  :init
  (progn
    (setq twittering-request-confirmation-on-posting t)
    (t/declare-prefix "a" "Applications"
                      "t" 'twittering-mode)))

#+END_SRC

** Sync with gcal

There was a time where this was working. For now it only causes problems, hence
the commented out ~org-gcal-fetch~

#+BEGIN_SRC emacs-lisp :results silent
(use-package org-gcal
  :ensure nil
  :straight nil
  :load-path "site-lisp/org-gcal/"
  :commands (org-gcal-sync org-gcal-fetch)
  :init
  (progn
    (when (boundp 't-org-gcal)
      (setq org-gcal-client-id t-org-gcal-client-id
            org-gcal-client-secret t-org-gcal-client-secret
            org-gcal-fetch-file-alist t-org-gcal-file-alist
            org-gcal-header-alist t-org-gcal-header-alist
            org-gcal-up-days 1)
      ;;(add-hook 'org-agenda-mode-hook 'org-gcal-fetch)
      )))

#+END_SRC

** Make org draw charts

#+BEGIN_SRC emacs-lisp :results silent
(use-package gnuplot :after org)
#+END_SRC

** Search

#+BEGIN_SRC emacs-lisp :results silent
(t/declare-prefix-for-mode 'org-mode "s" "Search"
                           "p" 'counsel-org-goto
                           "P" 'counsel-projectile-rg)
#+END_SRC

** Smartparens for org symbols

#+BEGIN_SRC emacs-lisp :results silent
(t/after smartparens
  (sp-with-modes 'org-mode
    (sp-local-pair "*" "*" :actions '(insert wrap) :unless '(sp-point-after-word-p sp-point-at-bol-p) :wrap "C-*" :skip-match 'sp--org-skip-asterisk)
    (sp-local-pair "~" "~" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "<" ">" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "=" "=" :unless '(sp-point-after-word-p) :post-handlers '(("[d1]" "SPC")))
    (sp-local-pair "«" "»")))

#+END_SRC

** Themes

#+BEGIN_SRC emacs-lisp :results silent
(use-package doom-themes
  :config
  (progn
    (setq doom-themes-enable-bold t
          doom-themes-enable-italic t)
    ;;(t/add-hook 'org-mode-hook 'doom-themes-org-config)
    ;;(t/add-hook 'neotree-mode-hook 'doom-themes-neotree-config)
    (doom-themes-visual-bell-config)))

(use-package doom-modeline
  :hook (after-init . doom-modeline-mode)
  :config
  (progn
    ;;(t/add-hook-setq 'js2-mode-hook doom-modeline-env-command "node -v 2>&1")
    (setq doom-modeline-height 40
          doom-themes-padded-modeline 1)))

(defconst t-themes (list
                    'doom-one
                    'doom-one-light) "Themes to cycle")

(defun t/cycle-theme ()
  "Cycles themes in `t-themes'"
  (interactive)
  (let ((first (car t-themes))
        (rest (cdr t-themes)))
    (setq t-themes (append rest (list first)))
    (car t-themes)))

(defun t/load-theme-cycle ()
  "Cycles `t-themes' and loads first theme in list"
  (interactive)
  (t/switch-theme (t/cycle-theme)))

(defun t/load-theme ()
  "Loads theme and fixes fringe bg color"
  (interactive)
  (t/switch-theme (car t-themes)))

(defun t/reset-font-after-load (&rest args) (interactive) (t/reset-font-size))
(advice-add 'load-theme :after 't/reset-font-after-load)

(defvar *t-theme-did-load* nil)
(defun t/load-theme-once ()
  (unless *t-theme-did-load*
    (setq *t-theme-did-load* t)
    (t/load-theme)))

(t/add-hook 'after-init-hook
            (lambda ()
              (if has-gui
                  (t/load-theme)
                (progn
                  ;; load-theme after making the frame also when in terminal emacs
                  (when (daemonp)
                    (add-hook 'after-make-frame-functions
                              (lambda (frame)
                                (with-selected-frame frame (t/load-theme-once))
                                ;; for some reason opening in terminal gives menu bar
                                (menu-bar-mode -1))))
                  (advice-add server-create-window-system-frame :after 't/load-theme-once)))))
#+END_SRC

** After

We're done, wrap up timing so we can se how long it took.

#+BEGIN_SRC emacs-lisp :results silent
(t/timing-end)
#+END_SRC

Editing the config alot these days.

#+BEGIN_SRC emacs-lisp :results silent
(find-file (locate-user-emacs-file "readme.org"))
#+END_SRC

Why, oh, why. It works for the initial file as well, though.

#+BEGIN_SRC emacs-lisp :results silent
(doom-modeline-init)
#+END_SRC
